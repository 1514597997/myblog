<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cookie_token_session</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/cookie_token_session/</url>
    <content><![CDATA[<ul>
<li>主要介绍各个区别<a href="https://zhuanlan.zhihu.com/p/631349844">参考文档</a></li>
<li>cookie<ul>
<li>浏览器存储的一种技术,可以根据不同网站,根据hash存储相关值</li>
<li>每次请求时会在请求头默认带cookie信息</li>
<li>早期用作当作登录验证后的一种免登录方式，后cookie可被编辑安全性问题，转移到使用session，或者搭配session实现用户身份验证</li>
<li>现在当作保存一些用户设置网页的一些参数配置</li>
</ul>
</li>
<li>session<ul>
<li>是服务器请求响应后，服务器生成和存储的session服务。</li>
<li>可以根据不同客户端生成不同session服务，根据各个客户端的session可以实现登录后，在session未过期内再次请求免登录。</li>
<li>安全身份验证推荐使用session+cookie的方式</li>
</ul>
</li>
<li>token<ul>
<li>一种新型的身份验证方式，首先登录验证后，服务器根据用户信息生成token，比如：md5(手机号+签名+时间戳+密钥)</li>
<li>用户在下次请求时携带token实现身份验证</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>开发项目周期</title>
    <url>/myblog/2025/11/06/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="项目立项"><a href="#项目立项" class="headerlink" title="项目立项"></a>项目立项</h1><ul>
<li>1.1- 项目的起点，由发起人或部门提出项目的想法，需要进行初步的可行性分析。</li>
<li>1.2- 组建项目团队或外包相关人员制作，根据项目的规模和复杂程度，确定项目团队成员。可能包括项目经理、需求分析师、系统架构师、程序员、测试工程师、文档工程师等角色。</li>
</ul>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ul>
<li>2.1- 需求收集：通过与客户沟通、访谈、问卷调查等方式收集需求。收集需求时要考虑功能性需求和非功能性需求。</li>
<li>2.2- 需求整理和分析：对收集到的需求进行分类、整理和分析，去除不合理或重复的需求。最终形成需求规格说明书，它是后续设计和开发阶段的重要依据。</li>
</ul>
<h1 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h1><ul>
<li>3.1 系统架构设计：架构师根据需求规格说明书设计系统的整体架构。包括技术选型，比如选择哪种编程语言、数据库管理系统、中间件等。比如电商系统主服务用什么语言开发？是否采用分布式服务？还是单体架构？是否使用集群？采用redis缓存等。</li>
<li>3.2 详细设计：对系统的各个模块进行详细设计，包括模块的接口设计、内部逻辑设计等。会形成详细设计说明书，为程序员编写代码提供详细的指导。例如，在设计一个视频播放软件的视频解码模块时，要详细设计解码算法的实现方式、与视频播放界面模块的接口参数等。</li>
</ul>
<h1 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h1><ul>
<li>4.1 代码编写：程序员根据详细设计说明书编写代码。他们会遵循一定的编程规范，如代码风格规范（缩进、命名规则等）和代码结构规范。可能会采用敏捷开发等方法进行迭代开发，每次迭代完成一部分功能的代码编写。</li>
<li>4.2 代码审查：通过代码审查来保证代码质量。可以采用同行评审的方式，让其他程序员对代码进行审查，检查代码是否存在逻辑错误、性能问题、安全漏洞等。</li>
</ul>
<h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><ul>
<li>5.1 单元测试：程序员对编写好的代码进行单元测试。例如：单据计算金额是否正确？</li>
<li>5.2 集成测试：当多个模块的代码集成在一起后进行集成测试。例如：对于OA系统，流程是否流转正常？流程指定人审批是否可正常审批？相关模板接口调用是否正常？</li>
<li>5.3 系统测试：对整个系统进行测试，包括功能测试（验证系统是否实现了需求规格说明书中的所有功能）、性能测试（测试系统的响应时间、吞吐量等性能指标）、安全测试（检查系统的安全性漏洞）等。</li>
<li>5.4 验收测试：由客户或者最终用户进行验收测试，以确定系统是否符合他们的需求。例如：制作的是财务系统，是否满足财务系统日常使用需求？</li>
</ul>
<h1 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h1><ul>
<li>6.1 部署计划制定：根据系统的规模和复杂程度制定部署计划。例如，对于一个大型企业级软件系统，需要考虑服务器的安装、网络配置、数据库初始化等步骤。</li>
<li>6.2 实际部署：将软件部署到生产环境中。例如，将一个网站应用部署到云服务器上，包括安装软件、配置服务器参数等操作。</li>
<li>6.3 部署后的监控和维护：在软件部署后，要进行监控，确保系统正常运行。例如，监控服务器的CPU使用率、内存使用情况等，及时发现并解决可能出现的问题。</li>
</ul>
<h1 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h1><ul>
<li>7.1 日常维护：对软件进行日常的维护工作，如修复软件在运行过程中出现的故障。例如：当用户反馈一个软件功能出现异常时，维护人员要及时查找原因并修复。</li>
<li>7.2 版本更新：根据用户反馈和业务需求进行版本更新。例如：财务系统更新新功能、更新修复Bug、更新安全漏洞等。</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>个人博客</title>
    <url>/myblog/2025/07/10/%E5%85%B6%E4%BB%96/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="以下是我个人的学习计划"><a href="#以下是我个人的学习计划" class="headerlink" title="以下是我个人的学习计划"></a>以下是我个人的学习计划</h1><div class="ds-markdown ds-markdown--block" style="--ds-md-zoom: 1.143;"><p class="ds-markdown-paragraph">
    <h3><strong>全栈工程师筑基计划</strong></h3>
    <p class="ds-markdown-paragraph"><strong>学习原则：先夯实单机能力，再扩展分布式系统</strong></p>
    <hr>
    <h4><strong>阶段1：数据库与ORM深度（4周/80分）</strong></h4>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>模块</th>
                <th>技术点</th>
                <th>作用</th>
                <th>技术分</th>
                <th>关键细节</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>JDBC核心</strong></td>
                <td>连接管理</td>
                <td>理解底层数据库交互</td>
                <td>🧠7</td>
                <td>分析DriverManager.getConnection()TCP握手过程，连接池validationQuery配置</td>
            </tr>
            <tr>
                <td></td>
                <td>事务控制</td>
                <td>手动事务管理基础</td>
                <td>🧠8</td>
                <td>setAutoCommit(false) + commit()/rollback()，对比自动提交模式性能差异</td>
            </tr>
            <tr>
                <td><strong>MyBatis深度</strong></td>
                <td>执行流程</td>
                <td>SQL映射核心机制</td>
                <td>🧠8</td>
                <td>跟踪SqlSessionFactoryBuilder解析mapper.xml全过程</td>
            </tr>
            <tr>
                <td></td>
                <td>缓存机制</td>
                <td>查询性能优化</td>
                <td>🚀6</td>
                <td>一级缓存(SqlSession)作用域陷阱，二级缓存Redis集成</td>
            </tr>
            <tr>
                <td></td>
                <td>动态SQL</td>
                <td>灵活构建复杂查询</td>
                <td>🚀5</td>
                <td><span class="ds-markdown-html">&lt;choose&gt;</span>/<span
                        class="ds-markdown-html">&lt;when&gt;</span>条件分支，<span
                        class="ds-markdown-html">&lt;foreach&gt;</span>批量插入优化
                </td>
            </tr>
            <tr>
                <td></td>
                <td>延迟加载</td>
                <td>关联对象按需加载</td>
                <td>🧠7</td>
                <td>代理对象实现原理：JavassistProxyFactory.invoke()拦截</td>
            </tr>
            <tr>
                <td><strong>事务专家-进行中</strong></td>
                <td>声明式事务</td>
                <td>Spring事务便捷管理</td>
                <td>🚀7</td>
                <td>@Transactional(isolation=REPEATABLE_READ, propagation=REQUIRED)</td>
            </tr>
            <tr>
                <td></td>
                <td>传播机制</td>
                <td>业务嵌套事务处理</td>
                <td>🧠9</td>
                <td>REQUIRES_NEW新建事务，NESTED嵌套事务，REQUIRED加入已有事务</td>
            </tr>
            <tr>
                <td></td>
                <td>失效场景</td>
                <td>避坑指南</td>
                <td>🧠9</td>
                <td>自调用/非public方法/异常类型错误/多线程切换/数据库引擎不支持</td>
            </tr>
            <tr>
                <td><strong>性能基石</strong></td>
                <td>连接池调优</td>
                <td>高并发资源管理</td>
                <td>🚀7</td>
                <td>Druid配置：maxActive=50, minIdle=5, testWhileIdle=true</td>
            </tr>
            <tr>
                <td></td>
                <td>执行计划分析</td>
                <td>SQL性能诊断</td>
                <td>🧠8</td>
                <td>EXPLAIN分析type/rows/Extra，强制索引FORCE INDEX</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h4><strong>阶段2：Spring核心强化（3周/60分）</strong></h4>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>模块</th>
                <th>技术点</th>
                <th>作用</th>
                <th>技术分</th>
                <th>关键细节</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>IOC容器</strong></td>
                <td>Bean生命周期</td>
                <td>掌握对象创建过程</td>
                <td>🧠8</td>
                <td>实例化→属性填充→Aware接口→BeanPostProcessor前置→init→后置</td>
            </tr>
            <tr>
                <td></td>
                <td>循环依赖</td>
                <td>解决组件相互引用</td>
                <td>🧠9</td>
                <td>三级缓存：singletonObjects/earlySingletonObjects/singletonFactories</td>
            </tr>
            <tr>
                <td><strong>AOP专家</strong></td>
                <td>代理机制</td>
                <td>动态增强实现</td>
                <td>🚀6</td>
                <td>JDK动态代理(接口) vs CGLIB(类)，proxyTargetClass=true强制CGLIB</td>
            </tr>
            <tr>
                <td></td>
                <td>事务源码</td>
                <td>掌握声明式事务原理</td>
                <td>🧠10</td>
                <td>跟踪TransactionInterceptor.invoke()→PlatformTransactionManager</td>
            </tr>
            <tr>
                <td><strong>SpringBoot</strong></td>
                <td>自动配置</td>
                <td>魔法解密</td>
                <td>🧠9</td>
                <td>@EnableAutoConfiguration加载META-INF/spring.factories机制</td>
            </tr>
            <tr>
                <td></td>
                <td>Starter开发</td>
                <td>企业组件封装</td>
                <td>🚀7</td>
                <td>自定义@ConditionalOnClass条件，spring-configuration-metadata.json配置提示</td>
            </tr>
            <tr>
                <td></td>
                <td>Actuator监控</td>
                <td>生产系统观测</td>
                <td>✅4</td>
                <td>暴露health/info端点，自定义DatabaseHealthIndicator</td>
            </tr>
            <tr>
                <td><strong>测试验证</strong></td>
                <td>事务实验</td>
                <td>传播机制验证</td>
                <td>🧠8</td>
                <td>REQUIRES_NEW独立事务回滚测试，NESTED嵌套事务回滚范围验证</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h4><strong>阶段3：缓存与高并发（5周/120分）</strong></h4>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>模块</th>
                <th>技术点</th>
                <th>作用</th>
                <th>技术分</th>
                <th>关键细节</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>并发基础</strong></td>
                <td>synchronized原理</td>
                <td>JVM锁机制</td>
                <td>🧠8</td>
                <td>对象头MarkWord分析，无锁→偏向锁→轻量锁→重量锁升级流程</td>
            </tr>
            <tr>
                <td></td>
                <td>JUC锁工具</td>
                <td>显式锁控制</td>
                <td>🚀6</td>
                <td>ReentrantLock公平锁实现，Condition精准唤醒</td>
            </tr>
            <tr>
                <td></td>
                <td>线程池核心</td>
                <td>资源池化管理</td>
                <td>🧠9</td>
                <td>ThreadPoolExecutor七大参数详解，CallerRunsPolicy拒绝策略</td>
            </tr>
            <tr>
                <td><strong>缓存专家</strong></td>
                <td>Redis管道</td>
                <td>批量操作优化</td>
                <td>🚀6</td>
                <td>pipeline.sync()减少RTT，对比普通操作性能提升300%</td>
            </tr>
            <tr>
                <td></td>
                <td>Lua脚本</td>
                <td>原子复杂操作</td>
                <td>🧠8</td>
                <td>redis.call('hset', KEYS[1], ARGV[1], ARGV[2]) 实现哈希操作</td>
            </tr>
            <tr>
                <td></td>
                <td>缓存击穿</td>
                <td>热点Key防护</td>
                <td>🚀7</td>
                <td>互斥锁重建 vs 逻辑过期 vs 永不过期策略对比</td>
            </tr>
            <tr>
                <td><strong>实战优化</strong></td>
                <td>本地缓存</td>
                <td>堆内存高效利用</td>
                <td>🚀6</td>
                <td>Caffeine配置：maximumSize=1000, expireAfterWrite=10m</td>
            </tr>
            <tr>
                <td></td>
                <td>异步编排</td>
                <td>并发任务处理</td>
                <td>🚀7</td>
                <td>CompletableFuture.thenCombine合并结果，orTimeout设置超时</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h4><strong>阶段4：分布式进阶（6周/160分）</strong></h4>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>模块</th>
                <th>技术点</th>
                <th>作用</th>
                <th>技术分</th>
                <th>关键细节</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>微服务基础</strong></td>
                <td>Eureka集群</td>
                <td>高可用注册中心</td>
                <td>🚀6</td>
                <td>3节点互注册，enableSelfPreservation=false关闭自我保护</td>
            </tr>
            <tr>
                <td></td>
                <td>Feign优化</td>
                <td>声明式服务调用</td>
                <td>🚀7</td>
                <td>配置connectTimeout=2000, readTimeout=5000，GZIP压缩支持</td>
            </tr>
            <tr>
                <td><strong>网关与安全</strong></td>
                <td>Gateway鉴权</td>
                <td>统一入口安全</td>
                <td>🚀7</td>
                <td>自定义GlobalFilter实现JWT+Redis双重校验</td>
            </tr>
            <tr>
                <td></td>
                <td>动态路由</td>
                <td>请求灵活分发</td>
                <td>🚀6</td>
                <td>Path=/user/** → lb://user-service，权重路由配置</td>
            </tr>
            <tr>
                <td><strong>分布式事务</strong></td>
                <td>Seata AT模式</td>
                <td>自动补偿事务</td>
                <td>🧠8</td>
                <td>@GlobalTransactional，undo_log表记录反向SQL</td>
            </tr>
            <tr>
                <td></td>
                <td>TCC模式</td>
                <td>高灵活事务</td>
                <td>🧠9</td>
                <td>@TwoPhaseBusinessAction实现Try/Confirm/Cancel三阶段</td>
            </tr>
            <tr>
                <td><strong>消息中间件</strong></td>
                <td>Kafka事务</td>
                <td>精确一次交付</td>
                <td>🧠8</td>
                <td>producer配置：enable.idempotence=true + transaction.id="tx_1"</td>
            </tr>
            <tr>
                <td></td>
                <td>顺序消费</td>
                <td>业务顺序保障</td>
                <td>🧠8</td>
                <td>MessageQueueSelector保证同一订单号哈希到相同队列</td>
            </tr>
            <tr>
                <td><strong>高可用</strong></td>
                <td>限流熔断</td>
                <td>系统稳定性保障</td>
                <td>🧠9</td>
                <td>Sentinel流控规则：QPS=1000，熔断策略：慢调用比例&gt;80%</td>
            </tr>
            <tr>
                <td></td>
                <td>分布式ID</td>
                <td>全局唯一标识</td>
                <td>🚀7</td>
                <td>雪花算法：时间戳(41bit)+机器ID(10bit)+序列号(12bit)</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h3><strong>学习路径规划表</strong></h3>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>学习阶段</th>
                <th>前置要求</th>
                <th>核心目标</th>
                <th>进入下一阶段标准</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>ORM与事务</strong></td>
                <td>Java基础</td>
                <td>掌握SQL执行原理和事务控制</td>
                <td>能手动实现MyBatis分页插件</td>
            </tr>
            <tr>
                <td><strong>Spring核心</strong></td>
                <td>完成阶段1</td>
                <td>理解IOC/AOP实现机制</td>
                <td>能解释Spring循环依赖解决方案</td>
            </tr>
            <tr>
                <td><strong>高并发实战</strong></td>
                <td>完成阶段2</td>
                <td>构建万级QPS单机服务</td>
                <td>Redis+Lua实现分布式限流组件</td>
            </tr>
            <tr>
                <td><strong>分布式系统</strong></td>
                <td>完成阶段3</td>
                <td>设计高可用微服务架构</td>
                <td>实现电商订单分布式事务场景</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h3><strong>每日学习任务表</strong></h3>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>时间段</th>
                <th>任务类型</th>
                <th>具体内容</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>晨间</strong></td>
                <td>原理研究</td>
                <td>深度分析1个🧠级技术点源码（如MyBatis执行器）</td>
            </tr>
            <tr>
                <td><strong>午间</strong></td>
                <td>技术验证</td>
                <td>编写测试用例验证理论（如事务传播机制实验）</td>
            </tr>
            <tr>
                <td><strong>晚间</strong></td>
                <td>项目实践</td>
                <td>在现有系统中实现2个技术点（如Redis管道优化+Feign超时配置）</td>
            </tr>
            <tr>
                <td><strong>周末</strong></td>
                <td>综合演练</td>
                <td>完成1个模块的深度优化（如实现Gateway统一鉴权）</td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h3><strong>避坑指南表</strong></h3>
    <div class="markdown-table-wrapper">
        <table>
            <thead>
            <tr>
                <th>技术领域</th>
                <th>常见陷阱</th>
                <th>解决方案</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>MyBatis</strong></td>
                <td>一级缓存引起脏读</td>
                <td>在select标签添加flushCache="true"</td>
            </tr>
            <tr>
                <td><strong>事务</strong></td>
                <td>@Transactional跨线程失效</td>
                <td>使用TransactionTemplate手动管理</td>
            </tr>
            <tr>
                <td><strong>缓存</strong></td>
                <td>缓存穿透攻击</td>
                <td>空值缓存：@Cacheable(unless="#result == null")</td>
            </tr>
            <tr>
                <td><strong>分布式锁</strong></td>
                <td>锁过期导致并发</td>
                <td>使用Redisson看门狗机制自动续期</td>
            </tr>
            <tr>
                <td><strong>Feign</strong></td>
                <td>超时配置不生效</td>
                <td>配置hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</td>
            </tr>
            </tbody>
        </table>
    </div>
    <blockquote><p class="ds-markdown-paragraph">
</div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><ul>
<li>当A.com域名去请求b.com域名下的资源时就会遇到跨域问题，跨域限制主要是由浏览器的同源策略引起的<ul>
<li>在东方精工项目中遇到使用frame打开双系统去浏览时遇到该问题，后续用户决定更换接口调用处理。</li>
<li>frame：父、子窗口这两个页面不同源，但是却想在iframe中获取父窗口的dom,造成了跨域问题</li>
</ul>
</li>
<li>详细参考 <a href="https://blog.csdn.net/jined/article/details/120693745">CSDN</a>;这里就只介绍解决方法<ul>
<li>前端解决方案<ul>
<li><p>JSONP</p>
<ul>
<li>原理：利用 &lt;script&gt; 标签的 src 属性没有跨域限制的特性，通过动态创建 script 标签来加载跨域服务器上的数据。</li>
<li>适用场景：只支持 GET 请求</li>
<li>代码示例:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;xxx&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">myCallback</span>(<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>代理</p>
<ul>
<li>原理：在开发环境中，前端请求先发送到一个同域的代理服务器，由代理服务器转发请求到目标服务器。</li>
<li>适用场景：主要用于开发阶段</li>
</ul>
</li>
<li><p>document.domain</p>
<ul>
<li>原理：通过设置 document.domain，使得主域相同但子域不同的页面能够共享 Cookie。</li>
<li>适用场景：仅限主域相同，子域不同的跨域应用场景</li>
<li>示例代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>window.postMessage</p>
<ul>
<li>原理：通过 postMessage 方法实现不同源的窗口之间安全地交换信息。</li>
<li>适用场景：可用于页面和其打开的新窗口、多窗口之间、页面与嵌套的 iframe 之间以及上述场景的跨域数据传递</li>
<li>示例代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口发送消息到子窗口</span></span><br><span class="line"><span class="keyword">var</span> childWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;https://test2.com&#x27;</span>);</span><br><span class="line">childWindow.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello, child window!&#x27;</span>, <span class="string">&#x27;https://test2.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 子窗口接收消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> === <span class="string">&#x27;https://test1.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from parent window: &#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>后端解决方案<ul>
<li>CORS（跨域资源共享）<ul>
<li>原理：服务器在响应头中设置特定的 CORS 响应头，告诉浏览器允许哪些源访问其资源。</li>
<li>适用场景：适用于所有需要跨域资源共享的场景，是最推荐的跨域解决方案</li>
<li>示例代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">https</span>:<span class="comment">//example.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: <span class="title class_">Content</span>-<span class="title class_">Type</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>设置响应头<ul>
<li>原理：后端直接在响应头中设置允许跨域的域名等信息。</li>
<li>适用场景：适用于各种后端框架，如 Java Spring Boot、Node.js 等</li>
<li>示例代码（SpringBoot）:<br>      <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>运维解决方案<ul>
<li>Nginx 代理<ul>
<li>原理：通过 Nginx 配置反向代理，将请求转发到目标服务器。</li>
<li>适用场景：适用于生产环境，支持 session 管理，无需对现有代码进行修改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/myblog/2025/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/</url>
    <content><![CDATA[<h1 id="Mysql-My-Structured-Query-Language"><a href="#Mysql-My-Structured-Query-Language" class="headerlink" title="Mysql (My Structured Query Language)"></a>Mysql (My Structured Query Language)</h1><ul>
<li>MySQL 是一种流行的关系型数据库管理系统（RDBMS）</li>
<li>一、MySQL 的基本概念<ul>
<li>1.1 数据库与表<ul>
<li>数据库是存储数据的仓库，表是数据库中用于存储数据的结构。一个表由行和列组成，行表示记录，列表示数据字段。</li>
<li>数据库通过 SQL（结构化查询语言）进行数据的增删改查操作。</li>
</ul>
</li>
<li>1.2 索引<ul>
<li>索引是一种提高查询性能的数据结构，通过创建索引可以加快数据的检索速度。MySQL 支持多种索引类型，如 B+树索引、哈希索引等。</li>
</ul>
</li>
<li>1.3 事务<ul>
<li>事务是一组必须作为整体执行的操作，如果其中一个操作失败，整个事务将回滚以保持数据的一致性。MySQL 支持事务处理，并遵循 ACID（原子性、一致性、隔离性、持久性）特性。</li>
</ul>
</li>
</ul>
</li>
<li>二、MySQL 的工作原理<ul>
<li>2.1 查询流程<ul>
<li>建立连接：客户端通过网络与 MySQL 服务器建立连接。</li>
<li>解析查询：MySQL 服务器接收到查询请求后，通过解析器将查询转换为内部数据结构。</li>
<li>查询优化：MySQL 通过查询优化器分析查询，选择最佳执行计划。</li>
<li>执行查询：MySQL 根据执行计划执行查询，并返回结果给客户端。</li>
<li>关闭连接：查询执行完毕后，客户端与 MySQL 服务器断开连接。</li>
</ul>
</li>
<li>2.2 日志系统<ul>
<li>redo log：用于记录数据的物理修改，确保数据在崩溃后可以恢复。</li>
<li>binlog：用于记录数据的逻辑修改，支持主从复制。</li>
<li>undo log：用于支持事务的回滚。</li>
</ul>
</li>
</ul>
</li>
<li>三、MySQL 的架构设计<ul>
<li>3.1 分层架构<ul>
<li>MySQL 的架构可以分为以下几层：</li>
<li>网络连接层：负责处理客户端的连接请求。</li>
<li>系统服务层：包括 SQL 接口、解析器、优化器和缓存缓冲区。</li>
<li>存储引擎层：支持多种存储引擎，如 InnoDB 和 MyISAM。</li>
<li>文件系统层：负责数据和日志的存储。</li>
</ul>
</li>
<li>3.2 存储引擎<ul>
<li>InnoDB：支持事务处理，适用于 OLTP 场景。</li>
<li>MyISAM：适合读密集型分析，但不支持事务。</li>
<li>Memory：全内存存储，适用于缓存和临时表。</li>
</ul>
</li>
</ul>
</li>
<li>四、MySQL 的性能优化<ul>
<li>4.1 索引优化<ul>
<li>合理设计索引，避免全表扫描。</li>
<li>使用 B+树索引提高范围查询性能。</li>
</ul>
</li>
<li>4.2 查询优化<ul>
<li>优化查询语句，避免不必要的连接操作。</li>
<li>使用查询缓存减少重复计算。</li>
</ul>
</li>
<li>4.3 配置优化<ul>
<li>调整缓冲区和线程池参数。</li>
<li>监控数据库性能并动态调整</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Jquery前端框架</title>
    <url>/myblog/2025/11/06/%E5%89%8D%E7%AB%AF/Jquery/</url>
    <content><![CDATA[<blockquote class="blockquote-center">jQuery 一种轻量级的 JavaScript 库</blockquote> 

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 是一种轻量级的 JavaScript 库，旨在简化 HTML 文档的遍历、事件处理、动画和 AJAX 操作。本文将从基本概念、工作原理、架构设计等多个方面深入解析 jQuery 的核心特性。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>


<h1 id="jQuery-的基本概念"><a href="#jQuery-的基本概念" class="headerlink" title="jQuery 的基本概念"></a>jQuery 的基本概念</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 的核心思想是“写得少，做得多”，通过简洁的语法和强大的功能，帮助开发者快速实现复杂的网页交互。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 提供了丰富的选择器，用于快速定位 HTML 元素。支持 CSS 选择器、XPath 选择器以及自定义选择器。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 支持链式调用，允许在一个语句中连续执行多个操作，提高代码的可读性和效率。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="jQuery-的工作原理"><a href="#jQuery-的工作原理" class="headerlink" title="jQuery 的工作原理"></a>jQuery 的工作原理</h1><h2 id="选择器引擎"><a href="#选择器引擎" class="headerlink" title="选择器引擎"></a>选择器引擎</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 的选择器引擎（Sizzle）负责解析选择器表达式，并返回匹配的 DOM 元素集合。它通过优化选择器的解析和匹配过程，提高查找效率。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 提供了一系列方法来操作 DOM 元素，包括添加、删除、修改元素及其属性。这些操作通过包装 DOM API，提供更简洁的接口。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 提供了统一的事件处理机制，支持多种事件类型（如点击、鼠标悬停等），并自动处理浏览器兼容性问题。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 简化了 AJAX 操作，通过 $.ajax 等方法，方便开发者进行异步数据请求和处理。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="jQuery-的架构设计"><a href="#jQuery-的架构设计" class="headerlink" title="jQuery 的架构设计"></a>jQuery 的架构设计</h1><h2 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 的架构采用模块化设计，核心模块包括选择器、DOM 操作、事件处理等，其他功能（如 AJAX、效果）作为扩展模块。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 提供了强大的插件系统，开发者可以扩展 jQuery 的功能，通过插件实现复杂的功能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>jQuery 设计时充分考虑了浏览器兼容性，支持从旧版 IE 到现代浏览器的多种环境。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="jQuery-的性能优化"><a href="#jQuery-的性能优化" class="headerlink" title="jQuery 的性能优化"></a>jQuery 的性能优化</h2><h3 id="选择器优化"><a href="#选择器优化" class="headerlink" title="选择器优化"></a>选择器优化</h3><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>使用高效的 CSS 选择器，如 ID 选择器。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>避免使用复杂的复合选择器。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>使用事件委托减少事件绑定数量。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>通过 on 方法绑定事件，提高性能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h3 id="链式调用-1"><a href="#链式调用-1" class="headerlink" title="链式调用"></a>链式调用</h3><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>使用链式调用减少 DOM 查询次数。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>优化代码结构，提高执行效率。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h3 id="缓存选择器"><a href="#缓存选择器" class="headerlink" title="缓存选择器"></a>缓存选择器</h3><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>缓存常用的选择器结果，避免重复查询。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>使用变量存储 DOM 元素引用。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Vue前端框架</title>
    <url>/myblog/2025/11/06/%E5%89%8D%E7%AB%AF/Vue/</url>
    <content><![CDATA[<blockquote class="blockquote-center">Vue 渐进式JavaScript框架</blockquote> 

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue.js 是一种用于构建用户界面的渐进式 JavaScript 框架，以其轻量、灵活和易于学习而闻名。本文将从基本概念、工作原理、架构设计等多个方面深入解析 Vue 的核心特性。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="Vue-的基本概念"><a href="#Vue-的基本概念" class="headerlink" title="Vue 的基本概念"></a>Vue 的基本概念</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 采用 MVVM（Model-View-ViewModel）架构，将数据（Model）、视图（View）和逻辑（ViewModel）分离，使得开发更加模块化和可维护。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 的核心特性之一是其响应式系统，能够自动追踪数据的变化并更新 DOM。开发者只需关注数据的变化，而不需要手动操作 DOM。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 提供了简洁的模板语法，通过指令（如 v-if、v-for）和表达式（如 ）来操作 DOM。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="Vue-的工作原理"><a href="#Vue-的工作原理" class="headerlink" title="Vue 的工作原理"></a>Vue 的工作原理</h1><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>数据劫持：Vue 通过 Object.defineProperty 或 Proxy 来劫持对象的属性，监听数据的变化。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>依赖收集：当数据被访问时，Vue 会自动收集依赖关系。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>调度更新：当数据发生变化时，Vue 会触发更新队列，批量更新视图。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 使用虚拟 DOM 来提高渲染性能：</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>创建虚拟节点：将 DOM 转换为 JavaScript 对象。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>比较差异：通过比较新旧虚拟节点的差异，确定需要更新的部分。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>最小化更新：只更新发生变化的 DOM 节点。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 组件具有完整的生命周期，从创建到销毁，每个阶段都有对应的钩子函数（如 created、mounted），方便开发者在不同阶段执行特定逻辑。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="Vue-的架构设计"><a href="#Vue-的架构设计" class="headerlink" title="Vue 的架构设计"></a>Vue 的架构设计</h1><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 强调组件化开发，将复杂的界面拆分为多个独立的组件，每个组件负责特定的功能。组件之间可以通过 props 和 events 进行通信。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 提供 .vue 文件格式，将 HTML、CSS 和 JavaScript 代码集中在一个文件中，提高开发效率。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Vue 提供了强大的插件系统，开发者可以扩展 Vue 的功能，如状态管理（Vuex）、路由管理（Vue Router）等。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="Vue-的性能优化"><a href="#Vue-的性能优化" class="headerlink" title="Vue 的性能优化"></a>Vue 的性能优化</h1><h2 id="组件优化"><a href="#组件优化" class="headerlink" title="组件优化"></a>组件优化</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>加载：通过动态导入组件，减少初始加载时间。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>缓存：使用 keep-alive 缓存组件，避免重复渲染。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="数据优化"><a href="#数据优化" class="headerlink" title="数据优化"></a>数据优化</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>计算属性：使用计算属性代替复杂逻辑，提高性能。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>防抖和节流：优化高频事件的处理，减少不必要的计算。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>虚拟滚动：对于大量数据的渲染，使用虚拟滚动技术。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>异步更新：通过 nextTick 等机制优化 DOM 更新。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/myblog/2025/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/</url>
    <content><![CDATA[<h1 id="Redis-Remote-Dictionary-Server"><a href="#Redis-Remote-Dictionary-Server" class="headerlink" title="Redis (Remote Dictionary Server)"></a>Redis (Remote Dictionary Server)</h1><ul>
<li>一、Redis 的基本概念<ul>
<li>Redis 是一种基于内存的键值数据库，支持多种数据结构，包括字符串、哈希、列表、集合和有序集合。它以其快速的读写性能、丰富的数据结构和灵活的持久化机制而闻名。</li>
<li>以下是特点<ul>
<li>高性能：Redis 将数据存储在内存中，读写速度极快。</li>
<li>丰富的数据结构：支持字符串、哈希、列表、集合、有序集合等。</li>
<li>持久化：支持 RDB（快照）和 AOF（日志）两种持久化方式。</li>
<li>高可用性：支持主从复制、哨兵模式和集群模式。</li>
</ul>
</li>
</ul>
</li>
<li>二、Redis 的工作原理<ul>
<li>2.1 架构设计<ul>
<li>Redis 采用单线程 + 多路复用机制，其核心架构包括网络模型、存储模型、持久化模块和复制与集群架构。</li>
</ul>
</li>
<li>2.1.1 为什么采用单线程？<ul>
<li>避免多线程上下文切换，减少 CPU 资源浪费。</li>
<li>大多数 Redis 操作是内存操作，速度足够快。</li>
<li>单线程保证操作的原子性，避免加锁开销。</li>
</ul>
</li>
<li>2.1.2 后台线程<ul>
<li>Redis 使用额外的后台线程处理 RDB&#x2F;AOF 持久化、过期键删除、客户端 IO 解析等任务。</li>
</ul>
</li>
<li>2.2 持久化机制<ul>
<li>Redis 提供两种持久化方式：</li>
<li>RDB（Redis Database Dump）：定期将内存中的数据快照保存到磁盘。</li>
<li>AOF（Append-Only File）：记录每次写操作的日志。</li>
</ul>
</li>
<li>2.3 高并发优化<ul>
<li>高效数据存储：通过压缩列表、跳表等优化查询速度。</li>
<li>过期键删除策略：惰性删除和定期删除相结合。</li>
</ul>
</li>
</ul>
</li>
<li>三、Redis 的应用场景<ul>
<li>3.1 缓存<ul>
<li>Redis 常用于缓存系统，通过快速读取数据避免重复计算。</li>
</ul>
</li>
<li>3.2 分布式锁<ul>
<li>Redis 提供了实现分布式锁的机制，确保分布式系统中资源的唯一性。</li>
</ul>
</li>
<li>3.3 消息队列<ul>
<li>Redis 的发布&#x2F;订阅模式和列表数据结构可以用于实现消息队列。</li>
</ul>
</li>
<li>3.4 排行榜<ul>
<li>使用有序集合可以快速实现排行榜功能。</li>
</ul>
</li>
<li>3.5 会话管理<ul>
<li>Redis 可以存储用户会话信息，支持高并发访问。</li>
</ul>
</li>
</ul>
</li>
<li>四、Redis 的性能优化<ul>
<li>4.1 合理选择数据结构<ul>
<li>根据实际需求选择合适的数据结构，例如使用字符串实现缓存，使用有序集合实现排行榜。</li>
</ul>
</li>
<li>4.2 设置合理的过期时间<ul>
<li>通过设置过期时间，避免内存泄漏和数据丢失。</li>
</ul>
</li>
<li>4.3 使用批量操作和 Pipeline<ul>
<li>批量操作和 Pipeline 可以减少网络往返时间，提高性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>C#编程语言</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/CSharp/CSharp/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><ul>
<li>基于.net的面向对象开发语言</li>
</ul>
<h1 id="NETCore与-NETFramework"><a href="#NETCore与-NETFramework" class="headerlink" title=".NETCore与.NETFramework"></a>.NETCore与.NETFramework</h1><ul>
<li>1.NET Framework<ul>
<li>微软开发的运行时环境，主要用于 Windows 平台。它依赖于 Windows 操作系统，与 Windows 系统深度集成。微软已停止更新</li>
</ul>
</li>
<li>2.NET Core <ul>
<li>是跨平台的运行时环境，支持 Windows、Linux 和 macOS 等多种操作系统。它通过抽象层来屏蔽不同操作系统之间的差异，使得应用程序可以在不同平台上运行。</li>
</ul>
</li>
</ul>
<h1 id="编程环境"><a href="#编程环境" class="headerlink" title="编程环境"></a>编程环境</h1><ul>
<li>1.安装.NET Core(Core自带了SDK和runtime)<ul>
<li>查看是否安装版本指令：dotnet -h（显示相关版本号）</li>
</ul>
</li>
<li>2.准备开发工具Ide、VisualStudio(微软官方开发工具，更适合C#)<ul>
<li>以下是各个版本的区别</li>
<li>isual Studio Community：这是一个免费的版本，适用于个人开发者、学术研究、教室学习和参与开源项目。它提供了完整的集成开发环境，支持Windows桌面、通用Windows应用、Web（ASP.NET）、Office 365、业务应用程序、Azure Stack、C++跨平台库开发、Python、Node.js、.NET Core和Docker工具。</li>
<li>Visual Studio Professional：这个版本适用于专业开发人员和小型团队，提供了更高级的调试和诊断工具、测试工具、跨平台开发支持和协作工具。它还包括PowerPoint情节提要、代码评审、任务暂停&#x2F;继续和团队资源管理器（第三方开发工具支持）等功能。</li>
<li>Visual Studio Enterprise：这是最全面的版本，提供了端到端的解决方案，以满足大型团队的严苛质量和规模需求。它包括所有Professional版本的功能，以及更高级的测试工具、协作工具和功能，如Visual Studio Live Share。</li>
</ul>
</li>
</ul>
<h1 id="编译与执行"><a href="#编译与执行" class="headerlink" title="编译与执行"></a>编译与执行</h1><ul>
<li>C#代码首先被编译成中间语言（IL），然后在.NET运行时（CLR）中进行即时编译（JIT） </li>
<li>和java类型预编译运行类似，但C#还会在运行时再即时编译运行</li>
<li>C#也拥有垃圾自动回收机制，但支持底层开发人员手动操作回收垃圾。</li>
</ul>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><ul>
<li>依赖项:应用编译、构建、开发时的依赖项SDK</li>
<li>Properties：.netCore项目的存放的配置信息，通过.json格式存放<ul>
<li>launchSettings.json:.netCore应用标准配置文件，包含环境变量、ip端口等</li>
</ul>
</li>
<li>wwwroot：网站根目录，存放前端静态资源，html、js、图片等。</li>
<li>Program.cs:.netCore应用的main方法，是项目启动的入口，负责配置和启动程序</li>
<li>Startup类:在.net5之后被废弃（原来的项目启动入口）</li>
</ul>
<h1 id="net-Web项目启动流程"><a href="#net-Web项目启动流程" class="headerlink" title=".net Web项目启动流程"></a>.net Web项目启动流程</h1><ul>
<li><p>1.运行时初始化</p>
<ul>
<li>1.1 加载.net进程，管理内存、执行代码、处理异常等核心功能</li>
<li>2.1 加载程序集：运行时加载项目中引用的程序集（如依赖的库文件），并解析依赖关系。</li>
<li>3.1 初始化配置系统：运行时会解析配置文件（如appsettings.json），并初始化配置系统。</li>
</ul>
</li>
<li><p>2.执行Program文件、文件内：1.构建宿主（Host）2. 配置服务 3. 构建应用程序 4.配置中间件管道 5.启动应用程序</p>
</li>
<li><p>3.初始化宿主（Host）WebApplication.CreateBuilder(args)</p>
<ul>
<li>3.1 Program代码中:WebApplication.CreateBuilder(args);宿主构建的起点。</li>
<li>3.2 CreateBuilder方法会初始化一个宿主构建器（HostBuilder），并配置默认的服务、配置源和日志提供者。<ul>
<li>3.2.1 加载默认的配置文件（如appsettings.json）。</li>
<li>3.2.2 初始化依赖注入容器,Ioc容器依赖注入</li>
<li>3.2.3 配置日志系统。</li>
<li>3.2.4 宿主生命周期管理服务：用于管理应用程序的启动和关闭过程。</li>
<li>3.2.5 其他基础服务：如IOptions、IConfiguration等。</li>
</ul>
</li>
</ul>
</li>
<li><p>4 添加服务</p>
<ul>
<li>4.1 builder.Services.AddControllers();微软配置默认服务:注册了MVC控制器。</li>
<li>4.2 builder.Services.AddEndpointsApiExplorer();微软配置默认服务:注册了端点API资源，这是Swagger&#x2F;OpenAPI支持的基础。</li>
<li>4.3 builder.Services.AddSwaggerGen();注册了Swagger生成器，用于生成OpenAPI文档。</li>
</ul>
</li>
<li><p>5 构建宿主（Host）</p>
<ul>
<li>5.4.1 Program执行到：var app &#x3D; builder.Build();这一行代码完成了宿主的构建过程。</li>
<li>5.4.2 Build方法内做的事情<ul>
<li>5.4.2.1 构建依赖注入容器。</li>
<li>5.4.2.2 为后续项目根据自己需求，微软会默认初始化一个空的中间件管道。</li>
<li>5.4.2.3 初始化日志系统和其他基础设施。</li>
</ul>
</li>
</ul>
</li>
<li><p>6.构配置中间件管道</p>
<ul>
<li>根据项目需求增加自定义管道</li>
<li>以下是微软默认提供可自主配置的管道</li>
<li>异常处理中间件<ul>
<li>在开发环境中显示详细的错误信息。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseDeveloperExceptionPage();</span><br></pre></td></tr></table></figure></li>
<li>捕获异常并返回友好的错误页面或错误信息。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseEndpoints(</span><br><span class="line">    endpoints =&gt;&#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">        endpoints.MapRazorPages();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>身份验证和授权<ul>
<li>提供身份验证支持，如JWT、Cookie等。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseAuthentication();</span><br></pre></td></tr></table></figure></li>
<li>提供授权支持，用于检查用户权限。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseAuthorization(); </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>跨域资源共享（CORS）<ul>
<li>配置跨域资源共享，允许或限制外部域对API的访问。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseCors(); </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>静态文件服务<ul>
<li>提供静态文件（如HTML、CSS、JavaScript）的访问支持。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseStaticFiles();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>路由和端点<ul>
<li>定义请求的路由规则。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseRouting();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>HTTPS重定向<ul>
<li>将所有HTTP请求重定向到HTTPS。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseHttpsRedirection();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>压缩响应<ul>
<li>对响应内容进行压缩，减少传输数据量。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseResponseCompression();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>请求本地化<ul>
<li>提供本地化支持，根据用户语言偏好返回本地化内容。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseRequestLocalization();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>会话管理<ul>
<li>管理用户会话，存储用户会话数据。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseSession();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>WebSockets支持<ul>
<li>启用WebSockets协议，支持实时通信。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseWebSockets();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>健康检查<ul>
<li>检查应用程序及其依赖项的运行状态。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseHealthChecks(<span class="string">&quot;/health&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>URL重写<ul>
<li>重写URL或重定向请求，用于SEO优化或路由调整。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseRewriter(</span><br><span class="line">    <span class="keyword">new</span> RewriteOptions().AddRedirect(<span class="string">&quot;old-path&quot;</span>, <span class="string">&quot;new-path&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>日志记录<ul>
<li>记录请求和响应的详细信息，用于调试和监控。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseLogging();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>单页应用程序（SPA）支持  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseSpa(spa =&gt;&#123;</span><br><span class="line">    spa.Options.SourcePath = <span class="string">&quot;ClientApp&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>其他中间件<ul>
<li>管理Cookie策略，确保Cookie的安全性。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseCookiePolicy();</span><br></pre></td></tr></table></figure></li>
<li>提供响应缓存支持，提高性能。  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>7.启动应用程序</p>
<ul>
<li>7.1 app.Run();<ul>
<li>7.1.1 启动Kestrel服务器，且开始根据配置的端口监听请求</li>
<li>7.1.2 运行中间件管道：HTTP请求会按照中间件管道中配置的顺序被处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><ul>
<li>C#中实现方法引用和回调机制的核心类型，类似于Java中的函数式接口</li>
<li>定义：委托是一种类型安全的函数指针，它定义了方法的签名（参数和返回类型），可以指向任何符合签名的方法。</li>
<li>核心作用：<ul>
<li>将方法作为参数传递（如回调）。</li>
<li>实现事件驱动编程（如按钮点击事件）。</li>
<li>解耦调用方与具体实现（如插件架构）。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Hibernate/</url>
    <content><![CDATA[<blockquote class="blockquote-center">Hibernate 一种全ORM(Object_Relative DateBase-Mapping)框架 </blockquote> 
Hibernate 的基本概念

<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><ul>
<li>Hibernate 是一个开源的对象关系映射（ORM）框架，用于将 Java 对象映射到关系型数据库。它通过提供透明的持久化机制，使开发者可以使用面向对象的方式操作数据库，而无需编写复杂的 SQL 语句。</li>
</ul>
<h1 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h1><ul>
<li>对象关系映射（ORM）：将 Java 类和数据库表进行映射，支持多种映射策略和注解。</li>
<li>数据库无关性：支持多种数据库（如 MySQL、Oracle、SQL Server 等），通过配置文件或注解实现数据库的无缝切换。</li>
<li>缓存机制：提供一级缓存（会话级别）和二级缓存（跨会话），提升查询性能。</li>
<li>事务管理：支持标准的 Java 事务 API（JTA）和本地事务管理。</li>
<li>延迟加载：按需加载关联对象，减少不必要的数据库访问。</li>
</ul>
<h1 id="Hibernate-的工作原理"><a href="#Hibernate-的工作原理" class="headerlink" title="Hibernate 的工作原理"></a>Hibernate 的工作原理</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul>
<li>Configuration：加载配置文件（如 hibernate.cfg.xml）和映射文件，初始化会话工厂。</li>
<li>SessionFactory：会话工厂，线程安全，负责创建 Session 对象。</li>
<li>Session：与数据库的会话接口，用于执行 CRUD 操作，非线程安全。</li>
<li>Transaction：事务管理接口，用于控制事务的开始、提交和回滚。</li>
<li>Query：用于执行数据库查询，支持 HQL（Hibernate Query Language）和原生 SQL。</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>配置加载：通过 Configuration 加载配置文件和映射文件。</li>
<li>创建会话工厂：使用 Configuration 构建 SessionFactory。</li>
<li>获取会话：通过 SessionFactory 创建 Session 对象。</li>
<li>事务管理：开启事务，执行数据库操作。</li>
<li>持久化操作：通过 Session 对象执行插入、更新、删除等操作。</li>
<li>提交事务：提交事务以确保数据一致性。</li>
<li>关闭资源：关闭 Session 和 SessionFactory。</li>
</ul>
<h1 id="Hibernate-的架构设计"><a href="#Hibernate-的架构设计" class="headerlink" title="Hibernate 的架构设计"></a>Hibernate 的架构设计</h1><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><ul>
<li>Hibernate 的架构分为以下层次：</li>
<li>Java 应用程序层：应用程序通过 Hibernate API 操作数据库。</li>
<li>Hibernate 框架层：包括核心组件如 SessionFactory、Session 和 Transaction。</li>
<li>后端 API 层：与 JDBC、JTA 和 JNDI 等 API 集成。</li>
<li>数据库层：与底层数据库交互。</li>
</ul>
<h2 id="核心组件关系"><a href="#核心组件关系" class="headerlink" title="核心组件关系"></a>核心组件关系</h2><ul>
<li>SessionFactory：线程安全的工厂类，负责创建 Session 对象。</li>
<li>Session：非线程安全的会话对象，用于执行数据库操作。</li>
<li>Transaction：事务管理接口，确保数据一致性。</li>
</ul>
<h1 id="Hibernate-的性能优化"><a href="#Hibernate-的性能优化" class="headerlink" title="Hibernate 的性能优化"></a>Hibernate 的性能优化</h1><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><ul>
<li>一级缓存：默认开启，用于缓存当前会话加载的对象。</li>
<li>二级缓存：跨会话缓存，可配置第三方缓存实现（如 Ehcache）。</li>
</ul>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul>
<li>HQL 查询：使用 HQL 优化复杂查询。</li>
<li>延迟加载：按需加载关联对象，减少不必要的数据库访问。</li>
</ul>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><ul>
<li>通过设置 hibernate.jdbc.batch_size 配置批量操作，提高大批量数据处理的效率</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>UnionAll语句</title>
    <url>/myblog/2025/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93/UnionAll/</url>
    <content><![CDATA[<h1 id="UnionAll使用语句"><a href="#UnionAll使用语句" class="headerlink" title="UnionAll使用语句"></a><a href="https://www.runoob.com/sql/sql-union.html">UnionAll使用语句</a></h1><ul>
<li>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>参考代码</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..</span><br></pre></td></tr></table></figure>
其中Oracle数据库中拼接的列名不能使用Null参数，必须给指定的类型对应！</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库基本介绍</title>
    <url>/myblog/2025/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="数据库的基本介绍"><a href="#数据库的基本介绍" class="headerlink" title="数据库的基本介绍"></a>数据库的基本介绍</h1><ul>
<li>事务（Transaction）是访问和更新数据库的程序执行单元，事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。</li>
<li>作为标准数据库需要支持ACID特性<ul>
<li>Atomicity：原子性<ul>
<li>原子性是指一个事务是一个不可分割的工作单位，要么全部成功，要么全部失败</li>
<li>通过UndoLog和事务机制实现</li>
</ul>
</li>
<li>Consistency：一致性<ul>
<li>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。必须保持逻辑一致性</li>
<li>由应用层和数据库共同保证</li>
</ul>
</li>
<li>Isolation：隔离性<ul>
<li>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>通过锁机制和MVCC实现</li>
</ul>
</li>
<li>Durability：持久性<ul>
<li>事务提交后结果永久保存</li>
<li>通过Redo Log实现</li>
</ul>
</li>
</ul>
</li>
<li>而为了隔离性、原子性、一致性引出了锁机制</li>
<li>锁机制颗粒度分基本介绍<ul>
<li>表锁：锁定整张表（MyISAM默认）<ul>
<li>特点：开销小，并发度低</li>
</ul>
</li>
<li>行锁：锁定单行记录（InnoDB默认）<ul>
<li>特点：开销大，并发度高</li>
</ul>
</li>
<li>页锁：锁定数据页（SQL Server等使用）</li>
<li>间隙锁（Gap Lock）锁定索引记录间的间隙<ul>
<li>解决幻读问题</li>
</ul>
</li>
<li>临键锁（Next-Key Lock）：行锁+间隙锁组合（InnoDB默认锁算法）</li>
</ul>
</li>
<li>锁机制性质基本介绍<ul>
<li>共享锁（S锁&#x2F;读锁）<ul>
<li>允许并发读，阻止其他事务获取排他锁</li>
</ul>
</li>
<li>排他锁（X锁&#x2F;写锁）<ul>
<li>阻止其他事务获取任何锁</li>
</ul>
</li>
<li>意向锁（Intention Lock）<ul>
<li>快速判断表是否被锁定（IS锁表有行级S锁，IX锁表有行级X锁）</li>
</ul>
</li>
</ul>
</li>
<li>特殊锁机制<ul>
<li>乐观锁<ul>
<li>是一种并发时的控制锁，即：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。</li>
<li>场景：读多写少的高并发环境</li>
<li>实现：可以使用版本号机制或 CAS 算法</li>
</ul>
</li>
<li>悲观锁<ul>
<li>假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</li>
<li>场景：业务数据要求完整且数据保证正确时使用</li>
<li>问题：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>EFCore</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/CSharp/EFCore/</url>
    <content><![CDATA[<h1 id="EFCore（Entity-Framework-Core）"><a href="#EFCore（Entity-Framework-Core）" class="headerlink" title="EFCore（Entity Framework Core）"></a>EFCore（Entity Framework Core）</h1><ul>
<li>介绍：轻量级、可扩展、开源且跨平台的对象关系映射ORM框架<ul>
<li>Entity Framework是上一代版本，而EFCore是专为Core版本设计制作<ul>
<li>dotnet指令安装“<a href="https://learn.microsoft.com/zh-cn/ef/core/cli/powershell">包管理器控制台工具</a>”  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure></li>
<li>更新“包管理器控制台工具”  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Update-Package</span> Microsoft.EntityFrameworkCore.Tools </span><br></pre></td></tr></table></figure></li>
<li>验证是否安装  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> about_EntityFrameworkCore</span><br></pre></td></tr></table></figure></li>
<li>安装成功响应如下  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line">                    _/\__</span><br><span class="line">            <span class="literal">---</span>==/    \\</span><br><span class="line">        ___  ___   |.    \|\</span><br><span class="line">        | __|| __|  |  )   \\\</span><br><span class="line">        | _| | _|   \_/ |  //|\\</span><br><span class="line">        |___||_|       /   \\\/\\</span><br><span class="line"></span><br><span class="line">TOPIC</span><br><span class="line">    about_EntityFrameworkCore</span><br><span class="line"></span><br><span class="line">SHORT DESCRIPTION</span><br><span class="line">    Provides information about the Entity Framework Core Package Manager Console Tools.</span><br><span class="line"></span><br><span class="line">&lt;A list of available commands follows, omitted here.&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>需安装对应EFCore的数据库支持，比如mysql，sqlserver</li>
</ul>
<h1 id="如何运用"><a href="#如何运用" class="headerlink" title="如何运用"></a>如何运用</h1><ul>
<li><p>1.创建定义模型类</p>
</li>
<li><p>2.创建继承 DbContext类,EF Core的核心类，用于管理实体的生命周期以及与数据库的交互。</p>
<ul>
<li>2.1重写OnConfiguring函数，加载数据库配置  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestWebApplication.yaohao.efcore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&amp;lt;YaoHao&amp;gt; YaoHao &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//泛型接口,表示数据库中的一个实体集合（即表）,映射数据库表</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AppDbContext</span>(<span class="params">DbContextOptions&lt;AppDbContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//必须公开具有 DbContextOptions&lt;?&gt; 参数的公共构造函数。才能在web通过依赖注入时启动 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里根据你的数据库use加载你所需要的数据库配置如: mysql、sqlserver</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//微软推荐这里进行配置实体的映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>3.迁移工具创建数据库</p>
<ul>
<li>程序包管理器控制台乱码处理UTF8指令:  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Console</span>]:<span class="link">:OutputEncoding = [System.Text.Encoding]::UTF8</span></span><br></pre></td></tr></table></figure></li>
<li>3.1 dotnet ef migrations add ‘迁移文件名’ &#x2F;&#x2F;创建一个新的迁移文件，用于描述数据库的初始结构<ul>
<li>分析模型变化<ul>
<li>如果是第一次运行迁移命令（即数据库尚未创建或迁移历史为空），EF Core 会根据实体模型生成数据库的初始结构。</li>
<li>如果数据库已经存在，EF Core 会检测实体模型的变化（如新增表、修改列、删除关系等）。然后去增量更新迁移文件</li>
</ul>
</li>
<li>生成迁移文件<ul>
<li>EF Core 会生成一个迁移文件，该文件包含两个主要部分<ul>
<li>Up 方法：描述如何将数据库从当前状态迁移到目标状态（即应用模型变化）。</li>
<li>Down 方法：描述如何撤销这些变化（回滚迁移）。</li>
</ul>
</li>
</ul>
</li>
<li>迁移文件命名<ul>
<li>迁移文件的名称由命令中的参数指定 ‘迁移文件名’。通常，迁移文件会存储在项目的 Migrations 文件夹中。</li>
</ul>
</li>
</ul>
</li>
<li>3.2 dotnet ef database update<ul>
<li>用于将迁移文件中定义的变更应用到数据库中，更新数据库的结构。</li>
<li>具体步骤<ul>
<li>读取迁移历史<ul>
<li>EF Core 会检查数据库中的 __EFMigrationsHistory 表，了解当前数据库已经应用了哪些迁移。</li>
</ul>
</li>
<li>应用未应用的迁移<ul>
<li>EF Core 会找到尚未应用到数据库的迁移文件，并按照顺序执行这些迁移文件中的 Up 方法，从而更新数据库结构。</li>
</ul>
</li>
<li>记录迁移历史<ul>
<li>每次应用迁移后，EF Core 会在 __EFMigrationsHistory 表中记录迁移的名称和时间戳，以便后续跟踪哪些迁移已经应用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul>
<li>efcore默认是有2个级别缓存。1、2级缓存</li>
<li>1级缓存微软默认开启，2级缓存需手动开启</li>
</ul>
<h1 id="运行链路"><a href="#运行链路" class="headerlink" title="运行链路"></a>运行链路</h1><ul>
<li>1.查询<ul>
<li>1.检查本地缓存<ul>
<li>在 DbContext 的 ChangeTracker 中查找已跟踪的实体</li>
<li>如果实体已被加载且未被标记为 Deleted，直接返回缓存副本</li>
</ul>
</li>
<li>2.生成 SQL <ul>
<li>若缓存未命中，构建参数化查询</li>
<li>根据主键值生成高效的 SELECT TOP(1) 语句。</li>
</ul>
</li>
<li>3.执行 SQL<ul>
<li>通过 ADO.NET 发送查询到数据库</li>
<li>使用连接池复用数据库连接。</li>
</ul>
</li>
<li>4.实体化结果<ul>
<li>将数据库返回的数据转换为 Product 对象</li>
<li>调用实体构造函数并填充属性。</li>
</ul>
</li>
<li>5.跟踪实体状态<ul>
<li>将实体添加到 ChangeTracker</li>
<li>状态标记为 Unchanged，后续修改会被跟踪。</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC连接方式</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/JDBC/</url>
    <content><![CDATA[<h1 id="Java语言链接数据库的一种方式"><a href="#Java语言链接数据库的一种方式" class="headerlink" title="Java语言链接数据库的一种方式"></a>Java语言链接数据库的一种方式</h1><p>JDBC菜鸟文档<a href="https://www.runoob.com/w3cnote/jdbc-use-guide.html">JDBC菜鸟文档</a></p>
<ul>
<li>支持多种数据库，mysql，Sqlserver等</li>
<li>大多主流使用的框架如Hinbate、Mytis等底层都使用jdbc方式连接</li>
<li>关于Jdbc连接需了解<ul>
<li>关于连接代码：Connection conn &#x3D; DriverManager.getConnection(URL, USER, PASSWORD);</li>
<li>资源消耗：每个连接都会占用数据库和应用的资源(内存、CPU)</li>
<li>连接池限制：数据库通常有最大连接数限制</li>
<li>性能影响：频繁创建&#x2F;关闭连接开销很大(连接池可缓解)</li>
<li>潜在泄漏：未关闭的连接会导致资源耗尽</li>
<li>事务管理：连接通常与事务生命周期绑定</li>
</ul>
</li>
<li>所以每个获取到的连接都需要管理好避免 死锁、连接数过高、等问题。</li>
<li>JDBC使用TCP方式连接<ul>
<li>使用过程<ul>
<li>第一步：加载Driver类，注册数据库驱动；</li>
<li>第二步：通过DriverManager,使用url，用户名和密码建立连接(Connection)；</li>
<li>第三步：通过Connection，使用sql语句打开Statement对象；</li>
<li>第四步：执行语句，将结果返回resultSet；</li>
<li>第五步：对结果resultSet进行处理；     </li>
<li>第六步：倒叙释放资源resultSet-》preparedStatement-》connection。</li>
</ul>
</li>
</ul>
</li>
<li>JDBC事务级别</li>
<li>一般手动提交事务会相比jdbc自动提交性能稍高一点。<table>
  <thead>
  <tr>
      <th>方法/设置</th>
      <th>作用____________________________________________</th>
      <th>示例代码</th>
  </tr>
  </thead>
  <tbody>
  <tr>
      <td>setAutoCommit(boolean autoCommit)</td>
      <td>开启/关闭自动提交模式（默认为 true，即每条 SQL 独立事务）</td>
      <td>conn.setAutoCommit(false); // 开启事务</td>
  </tr>
  <tr>
      <td>commit()</td>
      <td>提交当前事务（持久化更改）</td>
      <td>conn.commit();</td>
  </tr>
  <tr>
      <td>rollback()</td>
      <td>回滚当前事务（撤销未提交的更改）</td>
      <td>conn.rollback();</td>
  </tr>
  <tr>
      <td>setSavepoint()</td>
      <td>创建事务保存点（可部分回滚）</td>
      <td>Savepoint sp = conn.setSavepoint();</td>
  </tr>
  <tr>
      <td>rollback(Savepoint savepoint)</td>
      <td>回滚到指定保存点</td>
      <td>conn.rollback(sp);</td>
  </tr>
  <tr>
      <td>setTransactionIsolation(int level)</td>
      <td>设置事务隔离级别（影响锁行为和并发问题）</td>
      <td>conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);</td>
  </tr>
  </tbody>
</table></li>
<li>事务隔离级别（通过 JDBC 常量定义）<table>
  <thead>
  <tr>
      <th>隔离级别常量</th>
      <th>对应的数据库行为</th>
  </tr>
  </thead>
  <tbody>
  <tr>
      <td>TRANSACTION_READ_UNCOMMITTED (1)</td>
      <td>读未提交（可能脏读、幻读、不可重复读）</td>
  </tr>
  <tr>
      <td>TRANSACTION_READ_COMMITTED (2)</td>
      <td>读已提交（防止脏读，但可能幻读和不可重复读）</td>
  </tr>
  <tr>
      <td>TRANSACTION_REPEATABLE_READ (4)</td>
      <td>可重复读（防止脏读和不可重复读，可能幻读。InnoDB 通过间隙锁防止幻读）</td>
  </tr>
  <tr>
      <td>TRANSACTION_SERIALIZABLE (8)</td>
      <td>串行化（最高隔离级别，完全防止并发问题，性能最低）</td>
  </tr>
  </tbody>
</table></li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Mybatis/</url>
    <content><![CDATA[<h1 id="MyBatis-简介官网"><a href="#MyBatis-简介官网" class="headerlink" title="MyBatis 简介官网"></a>MyBatis 简介<a href="https://mybatis.net.cn/">官网</a></h1><ul>
<li>MyBatis 是一款优秀的持久层(半ORM)框架，主要功能是根据命名空间找到对应的xml中的sql执行。可以根据实体生成对应的基本sql执行。</li>
<li>它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object，普通的 Java对象)映射成数据库中的记录。</li>
</ul>
<h1 id="MyBatis-特点"><a href="#MyBatis-特点" class="headerlink" title="MyBatis 特点"></a>MyBatis 特点</h1><ul>
<li>MyBatis 框架具有以下特点：<ul>
<li>简单易学：MyBatis 框架本身很小且简单，没有任何第三方依赖。最简单的安装只需要两个 jar 文件加上几个 SQL 映射文件。通过文档和源代码，可以比较全面地掌握它的设计思路和实现。</li>
<li>灵活：MyBatis 不会对应用程序或者数据库的现有设计强加任何影响。SQL 写在 XML 里，便于统一管理和优化。通过 SQL 语句可以满足操作数据库的所有需求。</li>
<li>解除 SQL 与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。SQL 和代码的分离，提高了可维护性。</li>
<li>提供映射标签：支持对象与数据库的 ORM 字段关系映射。</li>
<li>提供对象关系映射标签：支持对象关系组建维护。</li>
<li>提供 XML 标签：支持编写动态 SQL。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-工作原理"><a href="#MyBatis-工作原理" class="headerlink" title=".MyBatis 工作原理"></a>.MyBatis 工作原理</h1><ul>
<li>MyBatis 的工作原理可以分为以下几个步骤：<ul>
<li>加载配置并初始化：加载配置文件，将 SQL 的配置信息加载成为一个个 MappedStatement 对象（包括了传入参数映射配置、执行的 SQL 语句、结果映射配置），存储在内存中。</li>
<li>接收调用请求：调用 MyBatis 提供的 API，传入 SQL 的 ID 和传入参数对象，将请求传递给下层的请求处理层进行处理。</li>
<li>处理操作请求：</li>
<li>根据 SQL 的 ID 查找对应的 MappedStatement 对象。</li>
<li>根据传入参数对象解析 MappedStatement 对象，得到最终要执行的 SQL 和执行传入参数。</li>
<li>获取数据库连接，根据得到的最终 SQL 语句和执行传入参数到数据库执行，并得到执行结果。</li>
<li>根据 MappedStatement 对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。</li>
<li>释放连接资源。</li>
<li>返回处理结果：将最终的处理结果返回。</li>
</ul>
</li>
<li>解析mapper.xml全过程<a href="https://www.cnblogs.com/Howinfun/p/12973902.html">解析映射sql文档参考</a><ul>
<li>1.参考代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       SpringApplication.run(UserApplication.class, args);</span><br><span class="line">       System.out.println(<span class="string">&quot;UserApplication Start&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">           System.out.println(<span class="string">&quot;inputStream&quot;</span>);</span><br><span class="line">           <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">           System.out.println(<span class="string">&quot;sqlSessionFactory&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span>(<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession())&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">               <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span>  session.getMapper(UserMapper.class);</span><br><span class="line">               List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">               <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">                   System.out.println(user.getId()+<span class="string">&quot;:&quot;</span>+user.getUsername());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;UserApplication Started&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>2.首先需要加载配置打开连接。使用SqlSessionFactoryBuilder管理SqlSession工厂</li>
<li>3.在SqlSessionFactoryBuilder().build(inputStream);时，<ul>
<li>build函数中首先构建生成XMLMapperEntityResolver(实体解析器)用与XML实体解析器,MyBatis(dtd格式)的实体解析器。</li>
<li>再根据XMLMapperEntityResolver(实体解析器)生成XPathParser(路径解析器)</li>
<li>XPathParser用与将io流处理成Document实体保存在XPathParser(路径解析器中)</li>
<li>到此构建了XMLConfigBuilder实体，接下来会默认执行XMLConfigBuilder.parse()解析参数函数</li>
<li>其中有个parseConfiguration函数，会尝试负责读取和解析MyBatis配置文件中的各个元素，如properties、settings、typeAliases等  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析配置信息</span></span><br><span class="line"><span class="comment">* 该方法负责读取和解析MyBatis配置文件中的各个元素，如properties、settings、typeAliases等</span></span><br><span class="line"><span class="comment">* 每个元素的解析可能会涉及加载属性、设置别名、配置插件等操作</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root 配置文件的根节点，通过它来访问配置文件中的各个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// issue #117 read properties first</span></span><br><span class="line">    <span class="comment">// 首先读取和解析properties元素，以加载自定义属性</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析settings元素，获取配置属性</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据配置属性加载自定义的VFS实现</span></span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据配置属性加载自定义的日志实现</span></span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析typeAliases元素，注册类型别名</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析plugins元素，加载插件</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析objectFactory元素，配置对象工厂</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析objectWrapperFactory元素，配置对象包装工厂</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析reflectorFactory元素，配置反射器工厂</span></span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析settings属性，应用配置</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">// 在解析了objectFactory和objectWrapperFactory之后解析environments元素，以配置环境</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析databaseIdProvider元素，配置数据库ID提供者</span></span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析typeHandlers元素，注册类型处理器</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析mappers元素，加载映射器</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 如果解析过程中发生错误，抛出BuilderException异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>parseConfiguration中加载插件、日志、实体、工厂、配置、反射等</li>
<li>其中到最后面mapperElement加载sql的mappers映射器，加载Mapper映射顺序：<package>标签指定包名、resource属性指定XML文件路径 、url属性指定XML文件路径、class属性指定接口的完全限定名  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析Mapper配置元素</span></span><br><span class="line"><span class="comment">* 该方法负责处理与Mapper相关的配置，包括从XML配置文件或类中加载Mapper接口</span></span><br><span class="line"><span class="comment">* 它根据子元素的名称和属性，决定是通过资源文件、URL还是类名来加载Mapper配置</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent 包含Mapper配置的父节点如果为null，则不执行任何操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception 如果解析过程中遇到错误，则抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">    <span class="comment">// 处理子元素为&quot;package&quot;的情况，表示批量加载一个包下的所有Mapper接口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据resource属性加载Mapper配置</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        ErrorContext.instance().resource(resource);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource)) &#123;</span><br><span class="line">            <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource,</span><br><span class="line">                configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 根据url属性加载Mapper配置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        ErrorContext.instance().resource(url);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url)) &#123;</span><br><span class="line">            <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url,</span><br><span class="line">                configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 根据class属性直接加载Mapper接口类</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">        configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 报错情况：子元素同时指定了多个加载方式</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(</span><br><span class="line">            <span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接下来是resource、和url模式的会使用XMLMapperBuilder.parse()去添加映射器,而pack包形势的解析会在执行接口时解析<ul>
<li>二者解析方式不同，一种是代码中执行解析，一种是xml启动时解析</li>
<li>XML 注册：启动时一次性加载，首次执行快但启动稍慢</li>
<li>Package 注册：启动快，但首次执行需要解析 SQL</li>
</ul>
</li>
<li>XMLMapperBuilder.parse();去解析映射文件，并确保所有必要的映射器都已正确绑定和解析</li>
<li>再就是bindMapperForNamespace();根据命名空间将标签与sql绑定到映射器,会解析所有的   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;cache-ref&gt;、&lt;cache&gt;、&lt;parameterMap&gt;、&lt;resultMap&gt;、&lt;sql&gt; 和 &lt;select|insert|update|delete&gt; 标签</span><br></pre></td></tr></table></figure></li>
<li>但bindMapperForNamespace(),中 parsePendingStatements()才是真正解析sql的函数  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析映射文件</span></span><br><span class="line"><span class="comment"> * 此方法主要用于解析映射文件，避免重复加载已解析的资源，并确保所有必要的映射器都已正确绑定和解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 检查资源是否已加载，以避免重复解析</span></span><br><span class="line">     <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">         <span class="comment">// 解析并处理mapper配置节点</span></span><br><span class="line">         configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">         <span class="comment">// 将资源标记为已加载，防止重复解析</span></span><br><span class="line">         configuration.addLoadedResource(resource);</span><br><span class="line">         <span class="comment">// 根据命名空间绑定映射器</span></span><br><span class="line">         bindMapperForNamespace();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析挂起的结果映射</span></span><br><span class="line">     parsePendingResultMaps();</span><br><span class="line">     <span class="comment">// 解析挂起的缓存引用</span></span><br><span class="line">     parsePendingCacheRefs();</span><br><span class="line">     <span class="comment">// 解析挂起的SQL语句</span></span><br><span class="line">     parsePendingStatements();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析配置元素，主要用于解析Mapper XML文件中的各种配置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context XNode对象，包含Mapper XML文件的节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取命名空间属性，这是Mapper配置中必须的属性</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">         <span class="comment">// 如果命名空间为空，抛出异常，因为命名空间是Mapper配置中不可或缺的部分</span></span><br><span class="line">         <span class="keyword">if</span> (namespace == <span class="literal">null</span> || namespace.isEmpty()) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 设置当前的命名空间，以便后续的配置解析可以正确关联到对应的Mapper</span></span><br><span class="line">         builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">         <span class="comment">// 解析并处理cache-ref元素，如果存在的话</span></span><br><span class="line">         cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">         <span class="comment">// 解析并处理cache元素，如果存在的话</span></span><br><span class="line">         cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">         <span class="comment">// 解析并处理所有的parameterMap元素</span></span><br><span class="line">         parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">         <span class="comment">// 解析并处理所有的resultMap元素</span></span><br><span class="line">         resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">         <span class="comment">// 解析并处理所有的sql元素</span></span><br><span class="line">         sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">         <span class="comment">// 根据上下文中的配置信息构建SQL语句</span></span><br><span class="line">         buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// 如果解析过程中发生异常，抛出BuilderException，包含错误的XML位置和原始异常信息</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析挂起的SQL语句节点</span></span><br><span class="line"><span class="comment"> * 此方法尝试解析所有尚未完成的SQL语句节点，这些节点在配置中被标记为不完整</span></span><br><span class="line"><span class="comment"> * 它通过同步的方式遍历不完整的SQL语句集合，尝试解析每个语句</span></span><br><span class="line"><span class="comment"> * 如果语句解析成功，则从不完整集合中移除；如果解析失败则保留，留待以后处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parsePendingStatements</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 获取配置中所有不完整的SQL语句集合</span></span><br><span class="line">     Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements();</span><br><span class="line">     <span class="comment">// 对不完整SQL语句集合进行同步，防止多线程环境下的并发修改问题</span></span><br><span class="line">     <span class="keyword">synchronized</span> (incompleteStatements) &#123;</span><br><span class="line">         <span class="comment">// 使用迭代器遍历不完整的SQL语句集合</span></span><br><span class="line">         Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator();</span><br><span class="line">         <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 尝试解析当前SQL语句节点</span></span><br><span class="line">             iter.next().parseStatementNode();</span><br><span class="line">             <span class="comment">// 解析成功后，从集合中移除该SQL语句</span></span><br><span class="line">             iter.remove();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">             <span class="comment">// 当前SQL语句仍然缺少资源，跳过本次解析，留待以后处理</span></span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li>parsePendingStatements()中循环解析sql语句节点执行XMLStatementBuilder.parseStatementNode()解析</li>
<li>其中有转换前的校验和是否有缓存相关校验、确认无误后，使用langDriver.createSqlSource()转换成SqlSource对象</li>
<li>最终构建 将转换sql的相关信息:id、结果集、主键、builderAssistant.addMappedStatement构建 MappedStatement 并添加到配置中  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析 XML 中的语句节点（如 &lt;select&gt;, &lt;insert&gt;, &lt;update&gt;, &lt;delete&gt;）并构建对应的 MappedStatement 对象。</span></span><br><span class="line"><span class="comment">* 该方法会处理节点属性、包含的子节点（如 &lt;include&gt;, &lt;selectKey&gt;），并根据配置生成 SQL 相关信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseStatementNode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取语句的 id 和 databaseId 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">databaseId</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数据库 ID 是否匹配，不匹配则跳过该语句</span></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="built_in">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点名称并转换为对应的 SQL 命令类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> context.getNode().getNodeName();</span><br><span class="line">    <span class="type">SqlCommandType</span> <span class="variable">sqlCommandType</span> <span class="operator">=</span> SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析缓存相关属性</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flushCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect); <span class="comment">// 是否刷新缓存，默认为非查询语句自动刷新</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);      <span class="comment">// 是否使用缓存，默认查询语句启用缓存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resultOrdered</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="literal">false</span>); <span class="comment">// 结果是否有序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 &lt;include&gt; 标签，将引用的 SQL 片段展开到当前节点</span></span><br><span class="line">    <span class="type">XMLIncludeTransformer</span> <span class="variable">includeParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLIncludeTransformer</span>(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parameterType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析语言驱动</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">    <span class="type">LanguageDriver</span> <span class="variable">langDriver</span> <span class="operator">=</span> getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 &lt;selectKey&gt; 标签并将其从当前节点中移除</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理主键生成策略</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    <span class="type">String</span> <span class="variable">keyStatementId</span> <span class="operator">=</span> id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">            ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用语言驱动解析 SQL 源码</span></span><br><span class="line">    <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析语句类型，默认为 PREPARED</span></span><br><span class="line">    <span class="type">StatementType</span> <span class="variable">statementType</span> <span class="operator">=</span> StatementType</span><br><span class="line">        .valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 fetchSize 和 timeout 属性</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">fetchSize</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数映射和结果映射相关属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parameterMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    <span class="type">String</span> <span class="variable">resultMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未指定 resultType 和 resultMap，则尝试从方法返回类型中获取</span></span><br><span class="line">    <span class="keyword">if</span> (resultTypeClass == <span class="literal">null</span> &amp;&amp; resultMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        resultTypeClass = MapperAnnotationBuilder.getMethodReturnType(builderAssistant.getCurrentNamespace(), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果集类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resultSetType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">    <span class="type">ResultSetType</span> <span class="variable">resultSetTypeEnum</span> <span class="operator">=</span> resolveResultSetType(resultSetType);</span><br><span class="line">    <span class="keyword">if</span> (resultSetTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">        resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键相关属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">keyColumn</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果集处理</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resultSets</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否影响数据（用于标识语句是否修改数据库数据）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dirtySelect</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;affectData&quot;</span>, Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终构建 MappedStatement 并添加到配置中</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap,</span><br><span class="line">        parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets, dirtySelect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>SqlSource接口中存放org.apache.ibatis.mapping.BoundSql对象,BoundSql存放着sql语句、参数、映射、内置参数等</li>
<li>所以具体还要看org.apache.ibatis.scripting.LanguageDriver中createSqlSource接口怎么创建成BoundSql对象的。</li>
<li>而Mybatis默认使用org.apache.ibatis.scripting.xmltags.XMLLanguageDriver的lang驱动，</li>
<li>Mybatis中Lang驱动有2种<ul>
<li>XMLLanguageDriver 为 XML 语言驱动，实现了动态 SQL 的功能，也就是说可以利用 MyBatis 提供的 XML 标签（常用的、等标签）结合OGNL表达式语法来实现动态的条件判断。</li>
<li>RawLanguageDriver 表示仅支持静态 SQL 配置，不支持动态 SQL 功能。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundSql</span> &#123;</span><br><span class="line">    <span class="comment">// Mapper配置解析后的sql语句</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line">    <span class="comment">// Mapper参数映射信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">    <span class="comment">// Mapper参数对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line">    <span class="comment">// 额外参数信息，包括&lt;bind&gt;标签绑定的参数，内置参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">    <span class="comment">// 参数对象对应的MetaObject对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br><span class="line">    <span class="comment">// ... 省略 get/set 和 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>其中可以看到2个createSqlSource函数实现<ul>
<li>第一个重载的 createSqlSource() 方法用于处理 XML 文件中配置的 SQL 信息，该方法中创建了一个 XMLScriptBuilder 对象，然后调用 XMLScriptBuilder 对象的 parseScriptNode() 方法将 SQL 资源转换为 SqlSource 对象。</li>
<li>第二个重载的 createSqlSource() 判断 SQL 配置是否以 script 标签开头。如果是，则以 XML 方式处理 Java 注解中配置的 SQL 信息；否则只是简单处理，</li>
</ul>
</li>
<li>解析还是得看最终执行得第一个重载函数，会先创建 XMLScriptBuilder 对象，接着调用 XMLScriptBuilder 对象 parseScriptNode() 方法解析SQL资源。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* XML语言驱动器，用于处理XML格式的SQL映射文件</span></span><br><span class="line"><span class="comment">* 该类实现了LanguageDriver接口，提供了一系列方法来处理SQL的解析和参数处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLLanguageDriver</span> <span class="keyword">implements</span> <span class="title class_">LanguageDriver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建参数处理器</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mappedStatement 映射语句对象，包含了一条SQL映射信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parameterObject 传递给SQL语句的参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> boundSql 封装了SQL文本和参数的对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回一个参数处理器，用于处理SQL语句中的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ParameterHandler <span class="title function_">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject,</span></span><br><span class="line"><span class="params">        BoundSql boundSql)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultParameterHandler</span>(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建SQL源</span></span><br><span class="line"><span class="comment">    * 该方法解析XML格式的SQL脚本，并生成一个SqlSource对象</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> configuration 配置对象，包含了MyBatis的全局配置信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> script XML脚本节点，包含了SQL的定义</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parameterType 传递给SQL语句的参数类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回一个SQL源对象，用于生成最终的SQL语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSource <span class="title function_">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> &#123;</span><br><span class="line">        <span class="type">XMLScriptBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLScriptBuilder</span>(configuration, script, parameterType);</span><br><span class="line">        <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建SQL源</span></span><br><span class="line"><span class="comment">    * 该方法处理两种情况：一是带有&lt;script&gt;标签的字符串，二是不带有&lt;script&gt;标签的字符串</span></span><br><span class="line"><span class="comment">    * 对于带有&lt;script&gt;标签的字符串，将其作为XML处理；对于不带有&lt;script&gt;标签的字符串，直接解析</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> configuration 配置对象，包含了MyBatis的全局配置信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> script SQL脚本字符串</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parameterType 传递给SQL语句的参数类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回一个SQL源对象，用于生成最终的SQL语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSource <span class="title function_">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span> &#123;</span><br><span class="line">        <span class="comment">// issue #3</span></span><br><span class="line">        <span class="keyword">if</span> (script.startsWith(<span class="string">&quot;&lt;script&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">XPathParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XPathParser</span>(script, <span class="literal">false</span>, configuration.getVariables(), <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>());</span><br><span class="line">        <span class="keyword">return</span> createSqlSource(configuration, parser.evalNode(<span class="string">&quot;/script&quot;</span>), parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// issue #127</span></span><br><span class="line">        script = PropertyParser.parse(script, configuration.getVariables());</span><br><span class="line">        <span class="type">TextSqlNode</span> <span class="variable">textSqlNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextSqlNode</span>(script);</span><br><span class="line">        <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DynamicSqlSource</span>(configuration, textSqlNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RawSqlSource</span>(configuration, script, parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li>
<li>到了parseDynamicTags()这里就要开始解析sql了, 把XML中写的SQL语句解析成一个可以动态拼接的SQL结构。<ul>
<li>可以看到循环所有文本节点用于判断，</li>
<li>Node.CDATA_SECTION_NODE或Node.TEXT_NODE时如果是文本节点（TEXT 或 CDATA）<ul>
<li>把文本内容取出来（比如 id &#x3D; #{id}）。</li>
<li>创建一个 TextSqlNode。</li>
<li>textSqlNode.isDynamic()&#x2F;&#x2F;判断它是不是动态内容（比如有没有 #{}、${}）。<ul>
<li>如果是，说明是动态 SQL，添加到 contents，并标记整个 SQL 是动态的。</li>
<li>如果不是，就作为静态 SQL 添加进去。</li>
</ul>
</li>
</ul>
</li>
<li>Node.ELEMENT_NODE，XML 标签（ELEMENT_NODE）<ul>
<li>获取标签名（比如 if、foreach）。</li>
<li>根据标签名找到对应的处理器（NodeHandler）</li>
<li>用这个处理器去处理这个标签，把处理结果添加到 contents。</li>
<li>因为标签本身就是动态逻辑，所以直接标记整个 SQL 是动态的。</li>
</ul>
</li>
</ul>
</li>
<li>最后返回MixedSqlNode(contents)，最用 MixedSqlNode 整理保存 SQL 转换的所有 SqlNode。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSource <span class="title function_">parseScriptNode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MixedSqlNode</span> <span class="variable">rootSqlNode</span> <span class="operator">=</span> parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource;</span><br><span class="line">    <span class="comment">// 判断Mapper SQL配置中是否包含动态SQL元素，如果是创建DynamicSqlSource对象，否则创建RawSqlSource对象</span></span><br><span class="line">    <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> <span class="title class_">DynamicSqlSource</span>(configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> <span class="title class_">RawSqlSource</span>(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析动态标签</span></span><br><span class="line"><span class="comment">* 该方法用于解析SQL语句中的动态标签，如条件语句、循环语句等</span></span><br><span class="line"><span class="comment">* 它通过遍历给定节点的所有子节点，根据节点类型处理不同的情况</span></span><br><span class="line"><span class="comment">* 对于文本节点，判断其是否为动态SQL的一部分；对于元素节点，使用相应的处理器进行处理</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node XML节点，代表SQL语句的一部分</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回一个MixedSqlNode，它包含了静态和动态SQL部分的解析结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> MixedSqlNode <span class="title function_">parseDynamicTags</span><span class="params">(XNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储解析后的SQL节点</span></span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取当前节点下所有的子节点</span></span><br><span class="line">    <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> node.getNode().getChildNodes();</span><br><span class="line">    <span class="comment">// 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的XNode包装当前子节点</span></span><br><span class="line">        <span class="type">XNode</span> <span class="variable">child</span> <span class="operator">=</span> node.newXNode(children.item(i));</span><br><span class="line">        <span class="comment">// 判断当前子节点的类型</span></span><br><span class="line">        <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">        <span class="comment">// 获取文本节点的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> child.getStringBody(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个TextSqlNode对象，用于解析动态SQL</span></span><br><span class="line">        <span class="type">TextSqlNode</span> <span class="variable">textSqlNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextSqlNode</span>(data);</span><br><span class="line">        <span class="comment">// 判断该文本节点是否为动态SQL的一部分</span></span><br><span class="line">        <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">            <span class="comment">// 如果是动态SQL，添加到contents中，并设置isDynamic为true</span></span><br><span class="line">            contents.add(textSqlNode);</span><br><span class="line">            isDynamic = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是动态SQL，作为静态文本添加到contents中</span></span><br><span class="line">            contents.add(<span class="keyword">new</span> <span class="title class_">StaticTextSqlNode</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">        <span class="comment">// 获取元素节点的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNode().getNodeName();</span><br><span class="line">        <span class="comment">// 根据节点名称获取相应的处理器</span></span><br><span class="line">        <span class="type">NodeHandler</span> <span class="variable">handler</span> <span class="operator">=</span> nodeHandlerMap.get(nodeName);</span><br><span class="line">        <span class="comment">// 如果没有找到对应的处理器，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用处理器处理当前节点，并将结果添加到contents中</span></span><br><span class="line">        handler.handleNode(child, contents);</span><br><span class="line">        <span class="comment">// 设置isDynamic为true，表示SQL中包含动态部分</span></span><br><span class="line">        isDynamic = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回包含所有解析结果的MixedSqlNode对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MixedSqlNode</span>(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当 &lt;select|insert|update|delete&gt; 标签解析完后，会利用工具类 MapperBuilderAssistant 的 addMappedStatement() 方法来将解析的所有信息封装为对应的 MappedStatement 对象，然后注册到 Configuration 中。</li>
<li>XML 文件解析完后，XMLMapperBuilder#parse() 方法会调用 Configuration#addLoadedResource() 方法将 XML 文件的资源路径注册到Configuration 中。</li>
<li>最后，在 XMLMapperBuilder#parse() 方法中还会调用 XMLMapperBuilder#bindMapperForNamespace() 方法，将 Mapper 接口注册到 Configuration 中。接口注册底层是使用 MapperRegistry 类，这个类会保存着所有 Mapper 接口的注册信息。在注册时，会为 Mapper 接口创建对应的 MapperFactoryBean；当执行 Mapper 时，可以根据当前 SqlSession 创建 Mapper 接口对应的 MapperProxy 代理实例。</li>
<li>XMLMapperBuilder#bindMapperForNamespace() 方法在 Mapper 接口注册后，还会创建 MapperAnnotationBuilder 对象来解析 Mapper 接口带 SQL 注解方法，也是生成对应的 MappedStatement 然后注册到 Configuration 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-架构"><a href="#MyBatis-架构" class="headerlink" title="MyBatis 架构"></a>MyBatis 架构</h1><ul>
<li>MyBatis 的功能架构可以分为三层：<ul>
<li>API 接口层：提供给外部使用的接口 API，开发人员通过这些本地 API 来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的 SQL 查找、SQL 解析、SQL 执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-核心组件"><a href="#MyBatis-核心组件" class="headerlink" title="MyBatis 核心组件"></a>MyBatis 核心组件</h1><ul>
<li>MyBatis 的核心组件包括：<ul>
<li>SqlSessionFactory：通过 MyBatis 环境等配置信息构造 SqlSessionFactory（会话工厂）。</li>
<li>SqlSession：通过会话工厂创建 SqlSession（会话），对数据库进行增删改查操作。</li>
<li>Executor：MyBatis 底层自定义了 Executor 执行器接口来具体操作数据库，Executor 接口有两个实现，一个基本执行器（默认），一个是缓存执行器，SqlSession 底层是通过 Executor 接口操作数据库。</li>
<li>MappedStatement：MyBatis 的一个底层封装对象，它包装了 MyBatis 配置信息与 sql 映射信息等。mapper.xml 中的 insert&#x2F;select&#x2F;update&#x2F;delete 标签对应一个 MappedStatement 对象。标签的 id 就是 MappedStatement 的 id。</li>
<li>SqlSource：负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回。</li>
<li>BoundSql：表示动态生成的 SQL 语句以及相应的参数信息。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-配置文件"><a href="#MyBatis-配置文件" class="headerlink" title="MyBatis 配置文件"></a>MyBatis 配置文件</h1><ul>
<li>MyBatis 的配置文件包括：<ul>
<li>mybatis-config.xml：MyBatis 的主配置文件，配置了全局配置文件，配置了 MyBatis 的运行环境等信息。</li>
<li>Mapper.xml：SQL 的映射文件，配置了操作数据库的 SQL 语句，此文件需在 mybatis-config.xml 中加载。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-动态-SQL"><a href="#MyBatis-动态-SQL" class="headerlink" title="MyBatis 动态 SQL"></a>MyBatis 动态 SQL</h1><ul>
<li>MyBatis 提供了动态 SQL 功能，可以使用强大的动态 SQL 来改进 SQL 语句条件连接的痛苦。动态 SQL 元素对于任何使用过 JSTL 或者类似于 XML 之类的文本处理器的人来说，都是非常熟悉的。在上一版本中，需要了解和学习非常多的元素，但在 MyBatis 3 中有了许多的改进，现在只剩下差不多二分之一的元素。MyBatis 使用了基于强大的 OGNL 表达式来消除了大部分元素。</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Maven/</url>
    <content><![CDATA[<blockquote class="blockquote-center">是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念</blockquote>

<ul>
<li>Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</li>
</ul>
<h1 id="Maven-的核心功能包括："><a href="#Maven-的核心功能包括：" class="headerlink" title="Maven 的核心功能包括："></a>Maven 的核心功能包括：</h1><pre><code>- 项目构建（编译、测试、打包、部署）
- 依赖管理（自动下载和管理第三方库）
- 标准化项目结构（约定优于配置）
- 插件扩展（支持自定义构建流程）
</code></pre>
<h1 id="pom-xml-详解"><a href="#pom-xml-详解" class="headerlink" title="pom.xml 详解"></a>pom.xml 详解</h1><pre><code>- 这是 Maven 的核心配置文件，定义了项目的基本信息和依赖。
- 项目生成的 pom.xml 示例：
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- POM 模型版本，固定 4.0.0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目坐标（唯一标识） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-first-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目打包方式（默认 jar，也可以是 war、pom 等） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称和 URL（可选） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my-first-app<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JUnit 测试依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  <span class="comment">&lt;!-- 仅用于测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  环境配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  构建配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>- 以下是maven的核心配置文件
&#123;%code %&#125;
<?xml version="1.0" encoding="UTF-8"?>

<!--
授权给 Apache 软件基金会 (ASF)，遵循一个或多个贡献者许可协议。
请查看随本作品分发的 NOTICE 文件，以获取关于版权所有权的额外信息。
ASF 根据 Apache 许可证 2.0 版本（"许可证"）向您授权本文件；
除非符合许可证的要求，否则您不得使用本文件。
您可以在以下网址获取许可证的副本：

    http://www.apache.org/licenses/LICENSE-2.0

除非适用法律要求或书面同意，依据本许可证分发的软件按"原样"分发，
无任何明示或暗示的担保或条件。请参阅许可证了解特定语言规定的权限和限制。
-->

<!--
 | 这是 Maven 的配置文件。它可以在两个级别指定：
 |
 |  1. 用户级别。此 settings.xml 文件为单个用户提供配置，
 |                 通常位于 $&#123;user.home&#125;/.m2/settings.xml。
 |
 |                 注意：此位置可以通过命令行选项覆盖：
 |
 |                 -s /path/to/user/settings.xml
 |
 |  2. 全局级别。此 settings.xml 文件为机器上的所有 Maven 用户提供配置
 |                 （假设他们都使用相同的 Maven 安装）。通常位于
 |                 $&#123;maven.conf&#125;/settings.xml。
 |
 |                 注意：此位置可以通过命令行选项覆盖：
 |
 |                 -gs /path/to/global/settings.xml
 |
 | 本示例文件中的部分旨在帮助您快速开始使用 Maven 安装。
 | 在适当的地方，提供了默认值（当未指定设置时使用的值）。
 |
 |-->
<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd">
  
  <!-- localRepository
   | Maven 用于存储构件的本地仓库路径。
   |
   | 默认值：$&#123;user.home&#125;/.m2/repository
  <localRepository>/path/to/local/repo</localRepository>-->
  <localRepository>D:\kaifagongju\maven</localRepository>
  
  <!-- interactiveMode
   | 这将决定 Maven 在需要输入时是否提示您。如果设置为 false，
   | Maven 将使用合理的默认值，可能基于其他一些设置。
   |
   | 默认值：true
  <interactiveMode>true</interactiveMode>
  -->
  
  <!-- offline
   | 决定 Maven 在执行构建时是否尝试连接网络。
   | 这将影响构件下载、构件部署等操作。
   |
   | 默认值：false
  
  <offline>false</offline>
	-->
	
  <!-- pluginGroups
   | 这是按前缀解析插件时将搜索的额外组标识符列表，即
   | 当调用像 "mvn prefix:goal" 这样的命令行时。如果列表中尚未包含，
   | Maven 会自动添加 "org.apache.maven.plugins" 和 "org.codehaus.mojo" 组标识符。
  -->
  <pluginGroups>
    <!-- pluginGroup
     | 指定用于插件查找的进一步组标识符。
    <pluginGroup>com.your.plugins</pluginGroup>
	-->
  </pluginGroups>

  <!-- 代理
   | 这是此机器上可用于连接网络的代理列表。
   | 除非另有指定（通过系统属性或命令行开关），否则将使用
   | 此列表中标记为活动的第一个代理规范。
  -->
  <proxies>
    <!-- proxy
     | 用于连接网络的一个代理规范。
    <proxy>
      <id>optional</id>
      <active>true</active>
      <protocol>http</protocol>
      <username>proxyuser</username>
      <password>proxypass</password>
      <host>proxy.host.net</host>
      <port>80</port>
      <nonProxyHosts>local.net|some.host.com</nonProxyHosts>
    </proxy>
	-->
  </proxies>

  <!-- servers
   | 这是认证配置文件的列表，由系统中使用的 server-id 作为键。
   | 每当 Maven 必须连接到远程服务器时，都可以使用认证配置文件。
  -->
  <servers>
    <!-- server
     | 指定连接到特定服务器时使用的认证信息，由系统内的
     | 唯一名称（由下面的 'id' 属性引用）标识。
     |
     | 注意：您应该指定 username/password 或 privateKey/passphrase，因为这些配对是
     |       一起使用的。
    <server>
      <id>deploymentRepo</id>
      <username>repouser</username>
      <password>repopwd</password>
    </server>
	-->
    <!-- 另一个示例，使用密钥进行认证 
    <server>
      <id>siteServer</id>
      <privateKey>/path/to/private/key</privateKey>
      <passphrase>optional; leave empty if not used.</passphrase>
    </server>
	-->
  </servers>

  <!-- mirrors
   | 这是用于从远程仓库下载构件的镜像列表。
   |
   | 工作原理如下：POM 可以声明一个用于解析某些构件的仓库。
   | 但是，此仓库有时可能会遇到流量大的问题，因此人们已将其
   | 镜像到多个位置。
   |
   | 该仓库定义将具有唯一 ID，因此我们可以为该仓库创建镜像引用，
   | 用作备用下载站点。镜像站点将是该仓库的首选服务器。
  -->
  <mirrors>
   <!-- 设置阿里云镜像源 -->
	<mirror>
		<id>aliyunmaven</id>
		<mirrorOf>*</mirrorOf>
		<name>阿里云公共仓库</name>
		<url>https://maven.aliyun.com/repository/public</url>
	</mirror>
    <!-- mirror
     | 指定要使用的仓库镜像站点，而不是给定的仓库。此镜像服务的
     | 仓库的 ID 与此镜像的 mirrorOf 元素匹配。ID 用于继承和直接查找目的，
     | 并且在镜像集中必须是唯一的。
    
    <mirror>
      <id>mirrorId</id>
      <mirrorOf>repositoryId</mirrorOf>
      <name>Human Readable Name for this Mirror.</name>
      <url>http://my.repository.com/repo/path</url>
    </mirror>
	-->
	
    <!-- 默认的 HTTP 拦截器镜像 
    <mirror>
      <id>maven-default-http-blocker</id>
      <mirrorOf>external:http:*</mirrorOf>
      <name>用于镜像最初使用 HTTP 的外部仓库的伪仓库。</name>
      <url>http://0.0.0.0/</url>
      <blocked>true</blocked>
    </mirror>
	-->
  </mirrors>

  <!-- profiles
   | 这是可以通过多种方式激活的配置文件列表，并且可以修改构建过程。
   | settings.xml 中提供的配置文件旨在提供特定于本地机器的路径和仓库位置，
   | 使构建能够在本地环境中工作。
   |
   | 例如，如果您有一个集成测试插件（如 cactus）需要知道 Tomcat 实例的安装位置，
   | 您可以在此处提供一个变量，以便在构建过程中取消引用该变量来配置 cactus 插件。
   |
   | 如上所述，可以通过多种方式激活配置文件。一种方式 - 本文档 (settings.xml) 的
   | activeProfiles 部分 - 将在后面讨论。另一种方式基本上依赖于属性的检测，
   | 要么匹配属性的特定值，要么仅测试其存在性。配置文件还可以通过 JDK 版本前缀激活，
   | 当构建在 '1.4.2_07' 版本的 JDK 上执行时，值 '1.4' 可能会激活配置文件。
   | 最后，可以从命令行直接指定活动配置文件的列表。
   |
   | 注意：对于在 settings.xml 中定义的配置文件，您仅限于指定构件仓库、
   |       插件仓库和用作 POM 中插件配置变量的自由形式属性。
  -->
  <profiles>
    <!-- profile
     | 指定一组构建过程的介绍，使用上述一种或多种机制激活。
     | 为了继承目的，并通过 <activatedProfiles/> 或命令行激活配置文件，
     | 配置文件必须具有唯一的 ID。
     |
     | 鼓励的最佳实践是使用一致的命名约定来标识配置文件，
     | 例如 'env-dev'、'env-test'、'env-production'、'user-jdcasey'、'user-brett' 等。
     | 这将使理解引入的配置文件集试图实现什么更加直观，
     | 特别是当您只有配置文件 ID 列表用于调试时。
     |
     | 此配置文件示例使用 JDK 版本触发激活，并提供特定于 JDK 的仓库。
    
    <profile>
      <id>jdk-1.4</id>
      <activation>
        <jdk>1.4</jdk>
      </activation>
      <repositories>
        <repository>
          <id>jdk14</id>
          <name>Repository for JDK 1.4 builds</name>
          <url>http://www.myhost.com/maven/jdk14</url>
          <layout>default</layout>
          <snapshotPolicy>always</snapshotPolicy>
        </repository>
      </repositories>
    </profile>
	-->
    <!-- 设置maven多环境配置 -->
    <profile>
      <id>jdk-1.8</id>
      <activation>
        <jdk>1.8</jdk>
      </activation>
      <properties>
		<maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	  </properties>
    </profile>
	
	<profile>
      <id>jdk-21</id>
      <activation>
        <jdk>21</jdk>
      </activation>
      <properties>
		<maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	  </properties>
    </profile>
	<!-- 设置maven多环境配置 -->
    <!--
     | 这是另一个配置文件，由属性 'target-env' 的值为 'dev' 激活，
     | 它提供了 Tomcat 实例的特定路径。要使用此功能，您的插件配置可能假设如下：
     |
     | ...
     | <plugin>
     |   <groupId>org.myco.myplugins</groupId>
     |   <artifactId>myplugin</artifactId>
     |
     |   <configuration>
     |     <tomcatLocation>$&#123;tomcatPath&#125;</tomcatLocation>
     |   </configuration>
     | </plugin>
     | ...
     |
     | 注意：如果您只想在有人将 'target-env' 设置为任何值时注入此配置，
     |       您可以只需在 activation-property 内部省略 <value/>。
    
    <profile>
      <id>env-dev</id>
      <activation>
        <property>
          <name>target-env</name>
          <value>dev</value>
        </property>
      </activation>
      <properties>
        <tomcatPath>/path/to/tomcat/instance</tomcatPath>
      </properties>
    </profile>
	-->
  </profiles>

  <!-- activeProfiles
   | 对所有构建都处于活动状态的配置文件列表。
  
  <activeProfiles>
    <activeProfile>alwaysActiveProfile</activeProfile>
    <activeProfile>anotherAlwaysActiveProfile</activeProfile>
  </activeProfiles>
  -->
</settings>
    &#123;%endcode%&#125;
</code></pre>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis缓存</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Mybatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<ul>
<li><p>理解1、2、3级缓存和实战 <a href="https://www.cnblogs.com/cxuanBlog/p/11324034.html">原理参考文档</a> <a href="https://zhuanlan.zhihu.com/p/23650823064">实战参考文档</a></p>
</li>
<li><p>缓存执行过程</p>
<ul>
<li>3级缓存（自定义应用级缓存）：redis\Ehcache<ul>
<li>因为二级缓存和一级缓存只适合单机单服务器的情况，针对集群或分布式就提供了自定义应用级缓存的方式解决</li>
<li>Ehcache是进程内缓存（JVM堆内存&#x2F;堆外内存+本地磁盘）很多缓存都存储在本地服务器中，所以更适合本地单机的服务器用作2级缓存</li>
<li>redis虽然本地没有Ehcache响应，但独立内存数据库，跨进程共享，且redis本身就支持分布式、哨兵等，所以更适合分布式和集群的缓存</li>
</ul>
</li>
<li>2级缓存:同一Mapper共享<ul>
<li>2级缓存相关配置参考说明 <a href="https://mybatis.net.cn/sqlmap-xml.html#cache">官服文档</a></li>
</ul>
</li>
<li>1级缓存:同一session时</li>
<li>最终db数据库执行sql<table><tr><th>缓存级别</th><th>作用域</th><th>生命周期</th><th>开启方式</th></tr><tr><td>一级缓存</td><td><span>SqlSession</span>级别</td><td>会话级（请求级）</td><td>默认开启</td></tr><tr><td>二级缓存</td><td>Mapper级别</td><td>应用级（跨会话）</td><td>需显式配置</td></tr><tr><td>三级缓存</td><td>应用集群级</td><td>分布式环境</td><td>需集成第三方</td></tr></table></li>
</ul>
</li>
<li><p>1级缓存 session级别缓存</p>
<ul>
<li>在同一个session中执行sql后会缓存执行的sql和结果</li>
<li><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">try(SqlSession <span class="keyword">session</span> = sqlSessionFactory.openSession())&#123;</span><br><span class="line">    UserMapper mapper =  <span class="keyword">session</span>.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;查询时间1开始:&quot;+<span class="keyword">System</span>.currentTimeMillis());</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; userList = mapper.getUserList();</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;查询时间1结束:&quot;+<span class="keyword">System</span>.currentTimeMillis());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">User</span> <span class="keyword">user</span> : userList) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">user</span>.getId()+&quot;:&quot;+<span class="keyword">user</span>.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;查询时间2开始:&quot;+<span class="keyword">System</span>.currentTimeMillis());</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; userList2 = mapper.getUserList();</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;查询时间2结束:&quot;+<span class="keyword">System</span>.currentTimeMillis());</span><br><span class="line">    <span class="keyword">if</span>(userList==userList2)&#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;缓存命中&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果</span><br><span class="line">//查询时间<span class="number">1</span>开始:<span class="number">1753322770960</span></span><br><span class="line">//查询时间<span class="number">1</span>结束:<span class="number">1753322771130</span></span><br><span class="line">//查询时间<span class="number">2</span>开始:<span class="number">1753322771135</span></span><br><span class="line">//查询时间<span class="number">2</span>结束:<span class="number">1753322771135</span></span><br><span class="line">//缓存命中</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2级缓存 Mapper级别的共享缓存</p>
<ul>
<li>Step1：全局启用缓存  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>Step2：Mapper文件声明缓存  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.user.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">flushInterval</span>=<span class="string">&quot;600000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通用查询结果列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">        id, username, password, email, phone, status, create_time, update_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.user.entity.User&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>  from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>测试代码  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; userList;</span><br><span class="line">List&lt;User&gt; userList2;</span><br><span class="line"><span class="keyword">try</span>(SqlSession session = sqlSessionFactory.openSession())&#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">    UserMapper mapper =  session.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;查询时间1开始:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    userList = mapper.getUserList();</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;userList长度:&quot;</span>+userList.<span class="keyword">size</span>());</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;查询时间1结束:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>(SqlSession session2 = sqlSessionFactory.openSession())&#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;session2&quot;</span>);</span><br><span class="line">    UserMapper mapper =  session2.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;查询时间2开始:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    userList2 = mapper.getUserList();</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;userList2长度:&quot;</span>+userList2.<span class="keyword">size</span>());</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;查询时间2结束:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (userList==userList2)&#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;二级缓存命中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line"><span class="comment">//session</span></span><br><span class="line"><span class="comment">//查询时间1开始:1753328802014</span></span><br><span class="line"><span class="comment">//userList长度:72</span></span><br><span class="line"><span class="comment">//查询时间1结束:1753328802125</span></span><br><span class="line"><span class="comment">//session2</span></span><br><span class="line"><span class="comment">//查询时间2开始:1753328802126</span></span><br><span class="line"><span class="comment">//userList2长度:72</span></span><br><span class="line"><span class="comment">//查询时间2结束:1753328802126</span></span><br><span class="line"><span class="comment">//二级缓存命中</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>3级缓存</p>
<ul>
<li>本质上是实现了org.apache.ibatis.cache.Cache 接口的2级缓存，<ul>
<li>这个接口定义了缓存的基本操作：putObject, getObject, removeObject, clear, getSize, getReadWriteLock，</li>
</ul>
</li>
<li>值得注意的是RedisCache二级缓存响应的是redis库中的数据，返回的实体不能用’&#x3D;&#x3D;’判断，因为实体在内存中不是同一个<ul>
<li>查询结果会存在redis中用hash命名实体,key(时间戳+全路径实体名+sql):value(sql结果)</li>
</ul>
</li>
<li>Ehcache则可以用’&#x3D;&#x3D;’判断,获取到的二级缓存是同一个  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//mapper文件</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.user.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>  <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// application文件 </span><br><span class="line"></span><br><span class="line">//开启缓存</span><br><span class="line">//mybatis-plus.configuration.cache-enabled=true</span><br><span class="line"></span><br><span class="line">//redis 配置</span><br><span class="line">//redis.host=localhost</span><br><span class="line">//redis.port=6379</span><br><span class="line">//redis.connectionTimeout=5000</span><br><span class="line">//redis.password=</span><br><span class="line">//redis.database=0</span><br><span class="line"></span><br><span class="line">//pom文件</span><br><span class="line">    <span class="comment">&lt;!-- mybatis cache --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ehcache --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mybatis redis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>测试响应  <figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">        List&lt;User&gt; userList;</span><br><span class="line">        List&lt;User&gt; userList<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession session = sqlSessionFactory.openSession())&#123;</span><br><span class="line">            UserMapper mapper =  session.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;查询时间1开始:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            userList = mapper.getUserList();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;查询时间1结束:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession session<span class="number">2</span> = sqlSessionFactory.openSession())&#123;</span><br><span class="line">            UserMapper mapper =  session<span class="number">2</span>.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;查询时间2开始:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            userList<span class="number">2</span> = mapper.getUserList();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;查询时间2结束:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userList==userList<span class="number">2</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;二级缓存命中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//reids测试结果 </span></span><br><span class="line"><span class="comment">//查询时间1开始:1753351457712</span></span><br><span class="line"><span class="comment">//查询时间1结束:1753351457825</span></span><br><span class="line"><span class="comment">//查询时间2开始:1753351457828</span></span><br><span class="line"><span class="comment">//查询时间2结束:1753351457829</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Ehcache测试结果</span></span><br><span class="line"><span class="comment">//查询时间1开始:1753352167864</span></span><br><span class="line"><span class="comment">//查询时间1结束:1753352167972</span></span><br><span class="line"><span class="comment">//查询时间2开始:1753352167974</span></span><br><span class="line"><span class="comment">//查询时间2结束:1753352167974</span></span><br><span class="line"><span class="comment">//二级缓存命中</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis延迟加载(懒加载)</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li>在Mybatis中使用多表联查时，可能会有不需要的数据被相关查询，这时就可以使用该技术优化节省查询次数。<ul>
<li>列如查询订单信息，默认关联用户、部门、岗位相关信息，可设置只有需要获取时才查询用户、部门、岗位相关信息</li>
</ul>
</li>
</ul>
<h2>使用示例:</h2>

<ul>
<li>先mybaits-config.xml全局配置懒加载<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//mybatis-config.xml 开启懒加载</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置mybatis全局属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--延迟加载 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 懒加载  避免在加载一个属性时就加载所有属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 积极加载  只有访问在访问到某个属性才执行相关sql --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--3.4.1版本之前默认是true，之后默认是false--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在Mapper文件中定义相关依赖sql和结构</li>
<li>部门Mapper:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通用查询映射结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.user.entity.Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;code&quot;</span> <span class="attr">property</span>=<span class="string">&quot;code&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;manager_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;managerId&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;parent_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;parentId&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;description&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">property</span>=<span class="string">&quot;remark&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 懒加载用户信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关联用户表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.user.mapper.UserMapper.queryUserByDepartmentId&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询部门相关所有用户映射结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserAndDepartment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.user.entity.Department&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.user.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;u_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用户密码</span></span><br><span class="line"><span class="comment">        &lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">property</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;u_status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;u_create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;u_update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;departmentId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentId&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据id获取部门 懒加载用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDepartmentMaybeUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from department where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>用户Mapper:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用查询结果列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    id, username, password, email, phone, status, create_time, update_time</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByDepartmentId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.user.entity.User&quot;</span> &gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>  from user u where  u.departmentId=#&#123;departmentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>服务调用示例:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@ApiOperation(value = &quot;获取部门 懒加载用户信息&quot;, notes = &quot;根据ID查询部门和懒加载用户信息&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getDepartmentMaybeUsers/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Department <span class="title function_">getDepartmentMaybeUsers</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始获取部门信息和懒加载用户&quot;</span>);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> departmentService.getDepartmentMaybeUsers(id);</span><br><span class="line"><span class="comment">//      java程序检测是否有使用懒加载相关逻辑</span></span><br><span class="line"><span class="comment">//        for (User user: department.getUsers()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(user);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        logger.info(<span class="string">&quot;结束获取部门信息和懒加载用户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SrpingMVC</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/SpinrgMVC/</url>
    <content><![CDATA[<div style="border: 2px solid white;
border-radius: 8px;
box-shadow: 0 0 15px rgba(0,0,0,0.15);">
<div class="markmap-wrap" 
      
      
    >
      <script type="application/json">{"content":"SpringMVC&#xff08;Spring Model View Control&#xff09;","children":[{"content":"&#x57fa;&#x4e8e; Java &#x548c; Spring &#x7684; Web &#x6846;&#x67b6;","children":[],"payload":{"tag":"li","lines":"1,2"}},{"content":"Model&#xff08;&#x6a21;&#x578b;&#xff09;&#xff1a;&#x8d1f;&#x8d23;&#x5e94;&#x7528;&#x7a0b;&#x5e8f;&#x7684;&#x4e1a;&#x52a1;&#x903b;&#x8f91;&#x548c;&#x6570;&#x636e;&#x3002;","children":[],"payload":{"tag":"li","lines":"2,3"}},{"content":"View&#xff08;&#x89c6;&#x56fe;&#xff09;&#xff1a;&#x8d1f;&#x8d23;&#x7528;&#x6237;&#x754c;&#x9762;&#x548c;&#x7528;&#x6237;&#x4ea4;&#x4e92;&#x3002;","children":[],"payload":{"tag":"li","lines":"3,4"}},{"content":"Controller&#xff08;&#x63a7;&#x5236;&#x5668;&#xff09;&#xff1a;&#x4f5c;&#x4e3a;&#x6a21;&#x578b;&#x548c;&#x89c6;&#x56fe;&#x4e4b;&#x95f4;&#x7684;&#x6865;&#x6881;&#x3002;","children":[{"content":"&#x901a;&#x5e38;&#x5728;SpringMVC&#x4f7f;&#x7528;&#x5143;&#x6ce8;&#x89e3;&#x6807;&#x6ce8;","children":[{"content":"@Controller:&#x6807;&#x8bb0;&#x4e00;&#x4e2a;&#x7c7b;&#x4e3a; Spring MVC &#x7684;&#x63a7;&#x5236;&#x5668;","children":[],"payload":{"tag":"li","lines":"6,7"}},{"content":"@RestController:@Controller &#x548c; @ResponseBody&#x7684;&#x7ec4;&#x5408;&#x521b;&#x5efa; RESTful &#x98ce;&#x683c;&#x7684;&#x63a7;&#x5236;&#x5668;,&#x5176;&#x6240;&#x6709;&#x65b9;&#x6cd5;&#x7684;&#x8fd4;&#x56de;&#x503c;&#x90fd;&#x5c06;&#x76f4;&#x63a5;&#x4f5c;&#x4e3a;&#x54cd;&#x5e94;&#x4f53;&#x8fd4;&#x56de;","children":[],"payload":{"tag":"li","lines":"7,8"}},{"content":"@RequestMapping:&#x7528;&#x4e8e;&#x5c06; HTTP &#x8bf7;&#x6c42;&#x6620;&#x5c04;&#x5230;&#x63a7;&#x5236;&#x5668;&#x65b9;&#x6cd5;&#x3002;","children":[],"payload":{"tag":"li","lines":"8,9"}},{"content":"@GetMapping&#x3001;@PostMapping&#x3001;@PutMapping&#x3001;@DeleteMapping:@RequestMapping &#x7684;&#x7279;&#x5b9a; HTTP &#x65b9;&#x6cd5;&#x7248;&#x672c;&#xff0c;&#x5206;&#x522b;&#x7528;&#x4e8e;&#x5904;&#x7406; GET&#x3001;POST&#x3001;PUT &#x548c; DELETE &#x8bf7;&#x6c42;","children":[],"payload":{"tag":"li","lines":"9,10"}},{"content":"@RequestParam:&#x7528;&#x4e8e;&#x5c06;&#x8bf7;&#x6c42;&#x53c2;&#x6570;&#x7ed1;&#x5b9a;&#x5230;&#x63a7;&#x5236;&#x5668;&#x65b9;&#x6cd5;&#x7684;&#x53c2;&#x6570;&#x4e0a;","children":[],"payload":{"tag":"li","lines":"10,11"}},{"content":"@PathVariable:&#x5c06; URL &#x4e2d;&#x7684;&#x4e00;&#x90e8;&#x5206;&#x4f5c;&#x4e3a;&#x63a7;&#x5236;&#x5668;&#x65b9;&#x6cd5;&#x7684;&#x53c2;&#x6570;","children":[],"payload":{"tag":"li","lines":"11,12"}},{"content":"@RequestBody:&#x5c06;&#x8bf7;&#x6c42;&#x4f53;&#x7684;&#x5185;&#x5bb9;&#x7ed1;&#x5b9a;&#x5230;&#x63a7;&#x5236;&#x5668;&#x65b9;&#x6cd5;&#x7684;&#x53c2;&#x6570;&#x4e0a;&#xff0c;&#x901a;&#x5e38;&#x7528;&#x4e8e;&#x5904;&#x7406; JSON &#x6216; XML &#x6570;&#x636e;","children":[],"payload":{"tag":"li","lines":"12,13"}},{"content":"@ResponseBody:&#x5c06;&#x63a7;&#x5236;&#x5668;&#x65b9;&#x6cd5;&#x7684;&#x8fd4;&#x56de;&#x503c;&#x76f4;&#x63a5;&#x5199;&#x5165; HTTP &#x54cd;&#x5e94;&#x4f53;&#x4e2d;","children":[],"payload":{"tag":"li","lines":"13,14"}},{"content":"@ModelAttribute:&#x5c06;&#x8bf7;&#x6c42;&#x53c2;&#x6570;&#x7ed1;&#x5b9a;&#x5230;&#x4e00;&#x4e2a;&#x5bf9;&#x8c61;&#x4e0a;&#xff0c;&#x6216;&#x8005;&#x5c06;&#x5bf9;&#x8c61;&#x6dfb;&#x52a0;&#x5230;&#x6a21;&#x578b;&#x4e2d;","children":[],"payload":{"tag":"li","lines":"14,15"}},{"content":"@ExceptionHandler: &#x5904;&#x7406;&#x63a7;&#x5236;&#x5668;&#x4e2d;&#x51fa;&#x73b0;&#x7684;&#x5f02;&#x5e38;","children":[],"payload":{"tag":"li","lines":"15,16"}}],"payload":{"tag":"li","lines":"5,16"}},{"content":"AbstractController:Spring MVC &#x6846;&#x67b6;&#x63d0;&#x4f9b;&#x7684;&#x4e00;&#x4e2a;&#x62bd;&#x8c61;&#x7c7b;","children":[{"content":"&#x5b9a;&#x4e49;&#x63a7;&#x5236;&#x5668;&#x7684;&#x57fa;&#x672c;&#x884c;&#x4e3a;&#xff1a;&#x5b83;&#x5b9a;&#x4e49;&#x4e86;&#x63a7;&#x5236;&#x5668;&#x7684;&#x57fa;&#x672c;&#x63a5;&#x53e3;&#x548c;&#x884c;&#x4e3a;&#x6a21;&#x5f0f;&#xff0c;&#x4f8b;&#x5982;&#x8bf7;&#x6c42;&#x5904;&#x7406;&#x3001;&#x54cd;&#x5e94;&#x751f;&#x6210;&#x7b49;&#x3002;","children":[],"payload":{"tag":"li","lines":"17,18"}},{"content":"&#x63d0;&#x4f9b;&#x8bf7;&#x6c42;&#x5904;&#x7406;&#x7684;&#x751f;&#x547d;&#x5468;&#x671f;&#x7ba1;&#x7406;&#xff1a;&#x5b83;&#x7ba1;&#x7406;&#x63a7;&#x5236;&#x5668;&#x7684;&#x521d;&#x59cb;&#x5316;&#x3001;&#x9500;&#x6bc1;&#x7b49;&#x751f;&#x547d;&#x5468;&#x671f;&#x4e8b;&#x4ef6;&#x3002;","children":[],"payload":{"tag":"li","lines":"18,19"}},{"content":"&#x652f;&#x6301;&#x591a;&#x79cd;&#x8bf7;&#x6c42;&#x5904;&#x7406;&#x65b9;&#x5f0f;&#xff1a;&#x5b83;&#x5141;&#x8bb8;&#x901a;&#x8fc7;&#x91cd;&#x5199;&#x65b9;&#x6cd5;&#x6765;&#x5b9e;&#x73b0;&#x4e0d;&#x540c;&#x7684;&#x8bf7;&#x6c42;&#x5904;&#x7406;&#x903b;&#x8f91;&#xff0c;&#x4f8b;&#x5982;&#x5904;&#x7406; GET &#x8bf7;&#x6c42;&#x3001;POST &#x8bf7;&#x6c42;&#x7b49;&#x3002;","children":[],"payload":{"tag":"li","lines":"19,20"}},{"content":"&#x63d0;&#x4f9b;&#x8bf7;&#x6c42;&#x6620;&#x5c04;&#x529f;&#x80fd;&#xff1a;&#x901a;&#x8fc7; handleRequest &#x65b9;&#x6cd5;&#xff0c;&#x5b83;&#x80fd;&#x591f;&#x5c06; HTTP &#x8bf7;&#x6c42;&#x6620;&#x5c04;&#x5230;&#x5177;&#x4f53;&#x7684;&#x5904;&#x7406;&#x903b;&#x8f91;&#x4e0a;&#x3002;","children":[],"payload":{"tag":"li","lines":"20,21"}},{"content":"&#x53ef;&#x7ee7;&#x627f;&#x91cd;&#x5199;&#x4ee5;&#x4e0b;&#x5185;&#x5bb9;&#xff1a;","children":[{"content":"handleRequestInternal(HttpServletRequest request, HttpServletResponse response)","children":[{"content":"&#x8fd9;&#x662f; AbstractController &#x4e2d;&#x6700;&#x6838;&#x5fc3;&#x7684;&#x65b9;&#x6cd5;&#x4e4b;&#x4e00;&#xff0c;&#x5b83;&#x7528;&#x4e8e;&#x5904;&#x7406;&#x5177;&#x4f53;&#x7684;&#x8bf7;&#x6c42;&#x3002;&#x901a;&#x8fc7;&#x91cd;&#x5199;&#x8fd9;&#x4e2a;&#x65b9;&#x6cd5;&#xff0c;&#x53ef;&#x4ee5;&#x5b9e;&#x73b0;&#x4ee5;&#x4e0b;&#x529f;&#x80fd;&#xff1a;","children":[],"payload":{"tag":"li","lines":"23,24"}},{"content":"&#x81ea;&#x5b9a;&#x4e49;&#x8bf7;&#x6c42;&#x5904;&#x7406;&#x903b;&#x8f91;&#xff1a;&#x6839;&#x636e;&#x8bf7;&#x6c42;&#x7684;&#x7c7b;&#x578b;&#xff08;&#x5982; GET&#x3001;POST&#xff09;&#x548c;&#x5185;&#x5bb9;&#xff0c;&#x5b9e;&#x73b0;&#x7279;&#x5b9a;&#x7684;&#x4e1a;&#x52a1;&#x903b;&#x8f91;&#x3002;","children":[],"payload":{"tag":"li","lines":"24,25"}},{"content":"&#x751f;&#x6210;&#x54cd;&#x5e94;&#x5185;&#x5bb9;&#xff1a;&#x53ef;&#x4ee5;&#x751f;&#x6210; HTML &#x9875;&#x9762;&#x3001;JSON &#x6570;&#x636e;&#x3001;XML &#x6570;&#x636e;&#x7b49;&#x4f5c;&#x4e3a;&#x54cd;&#x5e94;&#x8fd4;&#x56de;&#x7ed9;&#x5ba2;&#x6237;&#x7aef;&#x3002;","children":[],"payload":{"tag":"li","lines":"25,26"}},{"content":"&#x63a7;&#x5236;&#x8bf7;&#x6c42;&#x7684;&#x6d41;&#x5411;&#xff1a;&#x4f8b;&#x5982;&#xff0c;&#x6839;&#x636e;&#x8bf7;&#x6c42;&#x7684;&#x53c2;&#x6570;&#x6216;&#x7528;&#x6237;&#x6743;&#x9650;&#xff0c;&#x51b3;&#x5b9a;&#x662f;&#x76f4;&#x63a5;&#x8fd4;&#x56de;&#x54cd;&#x5e94;&#x8fd8;&#x662f;&#x8f6c;&#x53d1;&#x5230;&#x5176;&#x4ed6;&#x63a7;&#x5236;&#x5668;&#x3002;","children":[],"payload":{"tag":"li","lines":"26,27"}}],"payload":{"tag":"li","lines":"22,27"}},{"content":"afterPropertiesSet()","children":[{"content":"&#x8fd9;&#x662f;&#x4e00;&#x4e2a;&#x521d;&#x59cb;&#x5316;&#x56de;&#x8c03;&#x65b9;&#x6cd5;&#xff0c;&#x7ee7;&#x627f;&#x81ea; InitializingBean &#x63a5;&#x53e3;&#x3002;&#x901a;&#x8fc7;&#x91cd;&#x5199;&#x8fd9;&#x4e2a;&#x65b9;&#x6cd5;&#xff0c;&#x53ef;&#x4ee5;&#x5728;&#x63a7;&#x5236;&#x5668;&#x521d;&#x59cb;&#x5316;&#x5b8c;&#x6210;&#x540e;&#x6267;&#x884c;&#x4e00;&#x4e9b;&#x521d;&#x59cb;&#x5316;&#x64cd;&#x4f5c;&#xff0c;&#x4f8b;&#x5982;&#xff1a;&#x52a0;&#x8f7d;&#x914d;&#x7f6e;&#x6587;&#x4ef6;&#xff1a;&#x52a0;&#x8f7d;&#x4e1a;&#x52a1;&#x76f8;&#x5173;&#x7684;&#x914d;&#x7f6e;&#x4fe1;&#x606f;&#x3002;","children":[],"payload":{"tag":"li","lines":"28,29"}},{"content":"&#x521d;&#x59cb;&#x5316;&#x8d44;&#x6e90;&#xff1a;&#x521d;&#x59cb;&#x5316;&#x6570;&#x636e;&#x5e93;&#x8fde;&#x63a5;&#x3001;&#x7f13;&#x5b58;&#x7b49;&#x8d44;&#x6e90;&#x3002;","children":[],"payload":{"tag":"li","lines":"29,30"}},{"content":"&#x6821;&#x9a8c;&#x914d;&#x7f6e;&#xff1a;&#x68c0;&#x67e5;&#x914d;&#x7f6e;&#x662f;&#x5426;&#x6b63;&#x786e;&#xff0c;&#x786e;&#x4fdd;&#x63a7;&#x5236;&#x5668;&#x5728;&#x542f;&#x52a8;&#x65f6;&#x5904;&#x4e8e;&#x6b63;&#x786e;&#x7684;&#x72b6;&#x6001;&#x3002;","children":[],"payload":{"tag":"li","lines":"30,31"}}],"payload":{"tag":"li","lines":"27,31"}},{"content":"destroy()","children":[{"content":"&#x8fd9;&#x662f;&#x4e00;&#x4e2a;&#x9500;&#x6bc1;&#x56de;&#x8c03;&#x65b9;&#x6cd5;&#xff0c;&#x7ee7;&#x627f;&#x81ea; DisposableBean &#x63a5;&#x53e3;&#x3002;&#x901a;&#x8fc7;&#x91cd;&#x5199;&#x8fd9;&#x4e2a;&#x65b9;&#x6cd5;&#xff0c;&#x53ef;&#x4ee5;&#x5728;&#x63a7;&#x5236;&#x5668;&#x9500;&#x6bc1;&#x65f6;&#x6267;&#x884c;&#x4e00;&#x4e9b;&#x6e05;&#x7406;&#x5de5;&#x4f5c;&#xff0c;&#x4f8b;&#x5982;&#xff1a;","children":[],"payload":{"tag":"li","lines":"32,33"}},{"content":"&#x91ca;&#x653e;&#x8d44;&#x6e90;&#xff1a;&#x5173;&#x95ed;&#x6570;&#x636e;&#x5e93;&#x8fde;&#x63a5;&#x3001;&#x91ca;&#x653e;&#x6587;&#x4ef6;&#x53e5;&#x67c4;&#x7b49;&#x3002;","children":[],"payload":{"tag":"li","lines":"33,34"}},{"content":"&#x6e05;&#x7406;&#x7f13;&#x5b58;&#xff1a;&#x6e05;&#x9664;&#x63a7;&#x5236;&#x5668;&#x4e2d;&#x4f7f;&#x7528;&#x7684;&#x7f13;&#x5b58;&#x6570;&#x636e;&#xff0c;&#x907f;&#x514d;&#x5185;&#x5b58;&#x6cc4;&#x6f0f;&#x3002;","children":[],"payload":{"tag":"li","lines":"34,35"}}],"payload":{"tag":"li","lines":"31,35"}},{"content":"supportsMethod(String method)","children":[{"content":"&#x8fd9;&#x4e2a;&#x65b9;&#x6cd5;&#x7528;&#x4e8e;&#x5224;&#x65ad;&#x63a7;&#x5236;&#x5668;&#x662f;&#x5426;&#x652f;&#x6301;&#x67d0;&#x79cd; HTTP &#x65b9;&#x6cd5;&#xff08;&#x5982; GET&#x3001;POST&#x3001;PUT &#x7b49;&#xff09;&#x3002;&#x901a;&#x8fc7;&#x91cd;&#x5199;&#x8fd9;&#x4e2a;&#x65b9;&#x6cd5;&#xff0c;&#x53ef;&#x4ee5;&#x81ea;&#x5b9a;&#x4e49;&#x63a7;&#x5236;&#x5668;&#x652f;&#x6301;&#x7684; HTTP &#x65b9;&#x6cd5;&#xff0c;&#x4f8b;&#x5982;&#xff1a;","children":[],"payload":{"tag":"li","lines":"36,37"}},{"content":"&#x9650;&#x5236;&#x8bf7;&#x6c42;&#x65b9;&#x6cd5;&#xff1a;&#x53ea;&#x5141;&#x8bb8;&#x7279;&#x5b9a;&#x7684; HTTP &#x65b9;&#x6cd5;&#x8bbf;&#x95ee;&#x63a7;&#x5236;&#x5668;&#xff0c;&#x589e;&#x5f3a;&#x5b89;&#x5168;&#x6027;&#x3002;","children":[],"payload":{"tag":"li","lines":"37,38"}},{"content":"&#x52a8;&#x6001;&#x652f;&#x6301;&#x65b9;&#x6cd5;&#xff1a;&#x6839;&#x636e;&#x67d0;&#x4e9b;&#x6761;&#x4ef6;&#x52a8;&#x6001;&#x51b3;&#x5b9a;&#x652f;&#x6301;&#x7684; HTTP &#x65b9;&#x6cd5;&#x3002;","children":[],"payload":{"tag":"li","lines":"38,39"}}],"payload":{"tag":"li","lines":"35,39"}}],"payload":{"tag":"li","lines":"21,39"}}],"payload":{"tag":"li","lines":"16,39"}}],"payload":{"tag":"li","lines":"4,39"}},{"content":"&#x603b;&#x4f53;&#x5de5;&#x4f5c;&#x6d41;&#x7a0b;","children":[{"content":"DispatcherServlet&#xff1a;&#x524d;&#x7aef;&#x63a7;&#x5236;&#x5668;&#xff0c;&#x8d1f;&#x8d23;&#x63a5;&#x6536;&#x6240;&#x6709; HTTP &#x8bf7;&#x6c42;&#x5e76;&#x5206;&#x53d1;&#x7ed9;&#x5408;&#x9002;&#x7684;&#x5904;&#x7406;&#x5668;&#x3002;","children":[],"payload":{"tag":"li","lines":"40,41"}},{"content":"HandlerMapping&#xff1a;&#x786e;&#x5b9a;&#x54ea;&#x4e2a; Controller &#x5904;&#x7406;&#x5f53;&#x524d;&#x8bf7;&#x6c42;&#x3002;","children":[],"payload":{"tag":"li","lines":"41,42"}},{"content":"HandlerAdapter&#xff1a;&#x9002;&#x914d;&#x4e0d;&#x540c;&#x7c7b;&#x578b;&#x7684;&#x5904;&#x7406;&#x5668;&#xff08;Handler&#xff09;&#xff0c;&#x786e;&#x4fdd;&#x5b83;&#x4eec;&#x80fd;&#x591f;&#x88ab;&#x6b63;&#x786e;&#x8c03;&#x7528;&#x3002;","children":[],"payload":{"tag":"li","lines":"42,43"}},{"content":"Controller&#xff1a;&#x5904;&#x7406;&#x5177;&#x4f53;&#x7684;&#x4e1a;&#x52a1;&#x903b;&#x8f91;&#xff0c;&#x901a;&#x5e38;&#x662f;&#x4e00;&#x4e2a;&#x5e26;&#x6709; @Controller &#x6ce8;&#x89e3;&#x7684;&#x7c7b;&#x3002;","children":[],"payload":{"tag":"li","lines":"43,44"}},{"content":"ModelAndView&#xff1a;&#x5c01;&#x88c5;&#x6a21;&#x578b;&#x6570;&#x636e;&#x548c;&#x89c6;&#x56fe;&#x540d;&#x79f0;&#x3002;","children":[],"payload":{"tag":"li","lines":"44,45"}},{"content":"ViewResolver&#xff1a;&#x89e3;&#x6790;&#x89c6;&#x56fe;&#x540d;&#x79f0;&#xff0c;&#x8fd4;&#x56de;&#x5b9e;&#x9645;&#x7684; View &#x5bf9;&#x8c61;&#x3002;","children":[],"payload":{"tag":"li","lines":"45,46"}},{"content":"View&#xff1a;&#x8d1f;&#x8d23;&#x5c06;&#x6a21;&#x578b;&#x6570;&#x636e;&#x6e32;&#x67d3;&#x4e3a;&#x6700;&#x7ec8;&#x7684; HTML &#x9875;&#x9762;&#x3002;","children":[],"payload":{"tag":"li","lines":"46,47"}}],"payload":{"tag":"li","lines":"39,47"}}],"payload":{"tag":"li","lines":"0,47"}}</script>
      <script type="application/json">{}</script>
    </div>
</div>

<style>
.markmap {
  --markmap-text-color: #faf9f8;
}
</style>

<h1 id="思维导图未加载就请刷新网页"><a href="#思维导图未加载就请刷新网页" class="headerlink" title="思维导图未加载就请刷新网页"></a>思维导图未加载就请刷新网页</h1><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Spring/</url>
    <content><![CDATA[<blockquote class="blockquote-center">[Spring](https://springdoc.cn/spring/)</blockquote>

<ul>
<li>轻量级的Java EE（Java Platform, Enterprise Edition）开发框架</li>
<li>Spring 是一个基于控制反转（IoC）和面向切面编程（AOP）的框架，它通过 Java 反射机制以及其他技术来管理对象实例和实现其功能。</li>
<li></li>
</ul>
<h1 id="控制反转（Ioc）"><a href="#控制反转（Ioc）" class="headerlink" title="控制反转（Ioc）"></a>控制反转（Ioc）</h1><ul>
<li>一种设计思想,不是一种具体的技术。负责对象的创建、初始化以及依赖关系的管理</li>
<li>举例：A服务中有使用B服务，A依赖类B。弊端在传统模式中需要手动创建2种服务，依赖过多new实例维护过多。此时就可控制反转，通过IoC依赖注入，让依赖关系在IoC创建实例自动注入。实例化对象的权利就由用户转交给了Spring容器，这就叫作控制反转！</li>
<li>依赖注入（Dependency Injection，DI）实现 IoC 的一种方式，通过将依赖管理注入到对象中</li>
<li>Spring中IoC工作7步骤：资源加载，Bean 定义解析，Bean 实例化，依赖注入，初始化，使用，销毁<ul>
<li>1.资源加载：Spring 容器会读取配置文件或注解，这些配置信息定义了应用中的对象及其相互依赖的关系。</li>
<li>2.Bean定义解析：容器将配置信息解析为内部数据结构，每个定义的对象对应一个 BeanDefinition 对象，这个对象包含了类的信息、属性值等。</li>
<li>3.Bean实例化：Spring 容器通过反射机制，根据 BeanDefinition 中的信息创建对象实例。</li>
<li>4.依赖注入：容器会根据对象之间定义的依赖关系，通过反射将各个对象相互关联起来，完成依赖注入。</li>
<li>5.初始化：对象创建并注入依赖之后，Spring容器会调用对象的初始化方法，完成对象的初始化过程。</li>
<li>6.使用：初始化完成后，对象就可以被应用程序使用了。</li>
<li>7.销毁：当应用关闭时，Spring 容器会调用对象的销毁方法，进行资源的清理工作。</li>
<li>bean概念：想注入到 SpringIoC 容器的 Java 对象实例的抽象。</li>
</ul>
</li>
</ul>
<h1 id="面向切面编程AOP（Aspect-Orient-Programming）"><a href="#面向切面编程AOP（Aspect-Orient-Programming）" class="headerlink" title="面向切面编程AOP（Aspect Orient Programming）"></a>面向切面编程AOP（Aspect Orient Programming）</h1><ul>
<li>AOP是一种编程思想，是面向对象编程（OOP）的一种补充。</li>
<li>实现在不修改源代码的情况下给程序动态统一添加额外功能的一种方式</li>
<li>切面（Aspect）<ul>
<li>一个关注点的模块化，通常是一个类。切面通过 @Aspect 注解标记</li>
<li>切面声明，标注在类、接口（包括注解类型）或枚举上。</li>
<li>切面可以包含多个通知和切点</li>
</ul>
</li>
<li>连接点（Join Point）<ul>
<li>程序执行过程中的某个特定点</li>
<li>连接点是 AOP 框架在运行时可以动态插入通知的地方</li>
<li>在 SpringAOP 中，连接点由 JoinPoint 接口表示。</li>
</ul>
</li>
<li>通知（Advice）<ul>
<li>通知是在连接点上执行的代码。它定义了在连接点处应该执行的逻辑。</li>
<li>通知通过注解（如 @Before、@After、@Around 等）定义。</li>
<li>通知类别<ul>
<li>前置通知（Before Advice）：在连接点之前执行。</li>
<li>后置通知（After Advice）：在连接点之后执行，无论方法是否抛出异常。</li>
<li>返回通知（After Returning Advice）：在连接点正常返回后执行。</li>
<li>异常通知（After Throwing Advice）：在连接点抛出异常后执行。</li>
<li>环绕通知（Around Advice）：在连接点前后都可以执行，可以控制是否继续执行连接点。</li>
</ul>
</li>
</ul>
</li>
<li>切点（Pointcut）<ul>
<li>切点是通知应该应用到哪些连接点的表达式。</li>
<li>切点表达式可以指定方法名、类名、参数类型等条件。</li>
<li>切点可以组合使用，通过逻辑运算符（如 &amp;&amp;、||、!）来定义更复杂的条件。</li>
</ul>
</li>
<li>目标对象（Target Object）<ul>
<li>目标对象是被 AOP 代理的对象，通常是指包含业务逻辑的原始对象。</li>
<li>目标对象是业务逻辑的具体实现。</li>
<li>它可以是任何普通的 Java 对象，通常由 Spring 容器管理。</li>
<li>目标对象的方法可能会被 AOP 代理拦截，并在执行前后添加额外的逻辑。</li>
</ul>
</li>
<li>AOP 代理（AOP Proxy）<ul>
<li>AOP 代理是 AOP 框架动态生成的对象，用于实现通知的执行。</li>
<li>它实现了与目标对象相同的接口或继承了目标对象的类。</li>
<li>代理对象可以是通过 JDK 动态代理或 CGLIB 动态代理生成的<ul>
<li>如果目标对象没有实现任何接口，Spring 会使用 CGLIB 动态代理</li>
<li>目标对象实现了至少一个接口，Spring 默认使用 JDK 动态代理</li>
</ul>
</li>
</ul>
</li>
<li>织入（Weaving）<ul>
<li>SpringAOP织入不需要程序员操作，织入过程是自动完成的</li>
<li>织入是将切面（Aspect）应用到目标对象（Target Object）并创建新的代理对象（AOP Proxy）的过程</li>
<li>织入有几种方式：编译时织入，类加载时织入，<ul>
<li>编译时织入：在编译阶段将切面逻辑织入目标类中，生成新的字节码文件。</li>
<li>类加载时织入：在类加载阶段通过字节码操作技术，将切面逻辑织入目标类中</li>
<li>运行时织入：在运行时通过动态代理技术（JDK 动态代理或 CGLIB 动态代理），Spring AOP 默认采用运行时织入</li>
</ul>
</li>
<li>织入过程<ul>
<li>创建代理对象：Spring 根据目标对象的类型（是否实现了接口）选择使用 JDK 动态代理或 CGLIB 动态代理。</li>
<li>拦截方法调用：当客户端调用代理对象的方法时，代理对象会拦截这个调用。</li>
<li>执行通知逻辑：代理对象根据配置的通知类型，在调用目标方法前后执行相应的通知逻辑。</li>
<li>调用目标方法：在执行完通知逻辑后，代理对象调用目标对象的实际方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h1><ul>
<li>行为型设计模式，用于定义算法的骨架，将具体实现延迟到子类中。</li>
<li>Spring标准模板JdbcTemplate，封装了 JDBC 的操作流程，将通用的数据库操作（如连接、关闭资源等）放在模板类中</li>
</ul>
<h1 id="注解支持"><a href="#注解支持" class="headerlink" title="注解支持"></a>注解支持</h1><ul>
<li>Spring 提供了强大的注解支持，简化了配置XML和开发过程。</li>
<li>@Component：标记一个类为 Spring 管理的 Bean</li>
<li>@Service：标记一个类为服务层组件</li>
<li>@Repository：标记一个类为数据访问层组件</li>
<li>@Controller：标记一个类为控制器</li>
<li>@Autowired：用于注入依赖</li>
<li>@Transactional：用于声明事务</li>
</ul>
<h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><ul>
<li>Spring 的事件驱动机制基于观察者模式，允许组件之间通过事件进行解耦。</li>
<li>事件类（Event）<ul>
<li>事件类是 Spring 事件驱动机制中的核心，用于表示事件的内容和类型。</li>
<li>所有自定义事件都需要继承 ApplicationEvent 类</li>
<li>Spring内置事件类<ul>
<li>ContextRefreshedEvent：在 ApplicationContext 初始化或刷新时发布</li>
<li>ContextStartedEvent：在调用 ConfigurableApplicationContext 的 start() 方法时发布</li>
<li>ContextStoppedEvent：在调用 ConfigurableApplicationContext 的 stop() 方法时发布</li>
<li>ContextClosedEvent：在调用 ConfigurableApplicationContext 的 close() 方法时发布</li>
<li>RequestHandledEvent：在 Web 请求处理完成后发布</li>
</ul>
</li>
</ul>
</li>
<li>事件监听器（Listener）<ul>
<li>事件监听器用于监听并处理事件。</li>
<li>Spring内置2种事件监听<ul>
<li>ApplicationListener 是一个接口，用于监听特定类型的 ApplicationEvent</li>
<li>@EventListener 是一个注解,Spring 会自动注册该方法为事件监听器。</li>
</ul>
</li>
</ul>
</li>
<li>事件发布器（Publisher）<ul>
<li>Spring自动发布事件就是事件类提到的Spring内置的事件</li>
<li>开发者手动发布事件<ul>
<li>通过 ApplicationContext 发布事件,适合在应用程序的入口或配置类中使用，简单直接</li>
<li>通过 ApplicationEventPublisher 发布事件：适合在任何 Spring 管理的 Bean 中使用，更符合依赖注入的原则</li>
<li>通过 ApplicationEventMulticaster 广播事件：适合需要直接操作事件广播逻辑的场景</li>
<li>发布任意对象作为事件：适合快速发布简单的事件，但可能牺牲一些灵活性。</li>
<li>异步发布事件：适合需要提高响应性的场景，但需要额外配置线程池和异步支持</li>
</ul>
</li>
</ul>
</li>
<li>事件广播器（Multicaster）<ul>
<li>负责将事件分发给所有注册的监听器。它实现了发布-订阅模式，使得事件发布者和监听器之间解耦</li>
<li>ApplicationEventMulticaster 接口<ul>
<li>addApplicationListener：添加一个事件监听器</li>
<li>removeApplicationListener：移除一个事件监听器。</li>
<li>multicastEvent：广播事件给所有注册的监听器</li>
</ul>
</li>
<li>Spring 提供了 SimpleApplicationEventMulticaster 作为默认实现，它维护一个监听器列表，并在事件发生时逐个调用这些监听器</li>
<li>SimpleApplicationEventMulticaster 默认是同步处理事件的，即事件发布者会等待所有监听器处理完事件后才继续执行<ul>
<li>配置 TaskExecutor 可以实现异步事件处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot官网"><a href="#SpringBoot官网" class="headerlink" title="SpringBoot官网"></a>SpringBoot<a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/?utm_source=blog0716">官网</a></h1><ul>
<li>基于Spring框架的应用开发框架,SpringBoot继承了Spring框架的优秀特性</li>
<li>独立运行的Spring应用程序：Spring Boot允许开发者创建独立运行的Spring应用程序，无需部署到外部应用服务器</li>
<li>内嵌Servlet容器：Spring Boot默认内置了Tomcat、Jetty或Undertow等Servlet容器，开发者可以根据需要选择合适的容器</li>
<li>约定优于配置：当用户没有手动设置相关配置时，Spring Boot会根据应用程序的依赖和默认规则自动创建和配置Bean。</li>
<li>简化依赖管理：通过“starter”项目对象模型（POMs），Spring Boot简化了Maven配置</li>
<li>无需XML配置：Spring Boot采用注解和JavaConfig的方式进行配置，避免了繁琐的XML配置</li>
<li>Spring Boot 是构建微服务的理想选择，结合 Spring Cloud 可以轻松实现服务发现、负载均衡、熔断器等功能。</li>
<li>Spring Boot Actuator 监控<ul>
<li>用于监控和管理应用程序的模块</li>
<li>健康检查：通过 &#x2F;actuator&#x2F;health 端点检查应用程序的健康状态</li>
<li>性能指标：通过 &#x2F;actuator&#x2F;metrics 端点获取应用程序的性能指标</li>
<li>环境信息：查看应用程序的环境配置</li>
<li>日志级别管理：动态调整日志级别</li>
<li>自定义端点：开发者可以自定义监控端点</li>
</ul>
</li>
<li>外部化配置（Externalized Configuration）<ul>
<li>Spring Boot 支持通过多种方式加载配置信息，包括：</li>
<li>配置文件：如 application.properties 或 application.yml。</li>
<li>环境变量：可以通过环境变量覆盖配置文件中的值。</li>
<li>命令行参数：启动时通过命令行参数传递配置。</li>
<li>配置文件按环境分离：支持为不同环境（如开发、测试、生产）创建不同的配置文件，如 application-dev.properties</li>
</ul>
</li>
<li>启动器（Starters）<ul>
<li>Spring Boot 提供了一系列的“启动器”（Starter Dependencies），简化了依赖管理。常见的启动器包括：</li>
<li>spring-boot-starter-web：用于构建 Web 应用。</li>
<li>spring-boot-starter-data-jpa：用于 JPA 数据访问。</li>
<li>spring-boot-starter-test：用于测试。</li>
<li>spring-boot-starter-security：用于安全和认证。</li>
</ul>
</li>
<li>性能优化<ul>
<li>异步处理：通过 @Async 注解实现异步方法调用。</li>
<li>缓存支持：集成 Redis 或 Ehcache 提高性能。</li>
<li>连接池：使用 HikariCP 等高性能连接池。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/SpringCloud/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a><a href="https://springframework.org.cn/projects/spring-cloud/">SpringCloud</a></h1><ul>
<li>SpringCloud是基于SpringBoot的集合框架，主要用与开发分布式服务器。</li>
<li><ol>
<li>Spring Cloud 简介</li>
</ol>
<ul>
<li>Spring Cloud 是一系列框架的有序集合，利用 Spring Boot 的开发便利性，简化了分布式系统基础设施的开发。它整合了 Netflix 等公司的成熟框架，提供了服务发现注册、配置中心、消息总线、负载均衡、断路器等功能，是一套简单易用、易部署和易维护的分布式系统开发工具包。</li>
</ul>
</li>
<li><ol start="2">
<li>Spring Cloud 特点</li>
</ol>
<ul>
<li>集成性：深度集成 Netflix 开源组件，提供完整且经过实践检验的微服务解决方案。</li>
<li>易用性：遵循 Spring Boot 开发风格，提供丰富文档和社区支持。</li>
<li>灵活性：可根据项目需求选择适合的组件进行集成。</li>
<li>扩展性：支持水平或垂直扩展，适应业务发展。</li>
<li>可靠性：通过熔断器、负载均衡等机制，确保系统稳定性和可靠性。</li>
</ul>
</li>
<li><ol start="3">
<li>Spring Cloud 核心组件与原理</li>
</ol>
<ul>
<li>3.1 服务注册与发现<ul>
<li>服务提供者启动时，会将自己的网络地址、端口号等信息注册到注册中心（如 Eureka、Consul 或 Zookeeper 等），服务消费者通过注册中心查询所需服务的信息，实现服务的动态发现。</li>
</ul>
</li>
<li>3.2 负载均衡<ul>
<li>Spring Cloud 通过集成 Ribbon 或 Feign 等组件来实现负载均衡，根据一定的算法选择合适的服务实例进行请求转发。</li>
</ul>
</li>
<li>3.3 容错处理<ul>
<li>引入熔断器模式（如 Hystrix），在服务调用出现连续失败时，暂时停止对该服务的调用，避免进一步的资源浪费和性能下降。</li>
</ul>
</li>
<li>3.4 服务网关<ul>
<li>服务网关（如 Zuul 或 Spring Cloud Gateway）作为微服务架构的入口，负责处理外部请求并转发到内部的服务实例上，支持动态路由、请求过滤、安全认证等功能。</li>
</ul>
</li>
<li>3.5 配置管理<ul>
<li>Spring Cloud Config 将配置信息存储在外部的配置中心（如 Git 仓库、数据库等），各个微服务在启动时从配置中心获取所需的配置信息，支持配置的版本控制和动态刷新功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>HEXO</title>
    <url>/myblog/2025/11/06/%E5%B7%A5%E5%85%B7/hexo/hexo/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一种快速、简单高效编写博客的框架。<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p>
<p>个人使用主题:next <a href="https://github.com/next-theme/hexo-theme-next/blob/master/docs/zh-CN/README.md">next官网</a><br>个人使用思维导图：<a href="https://markmap.org/zh-cn/hexo-markmap/">hexo-markmap</a></p>
<p>同时支持安装各种第三方插件拓展</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">代码块示例:</span><br><span class="line"></span><br><span class="line">&#x27;Hello World!&#x27;</span><br><span class="line"><span class="keyword">Test</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>node-js</title>
    <url>/myblog/2025/11/06/%E5%B7%A5%E5%85%B7/hexo/node-js/</url>
    <content><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul>
<li>介绍<ul>
<li>Node.js 是一个开源的、跨平台的 JavaScript 运行时环境，它允许开发者在服务器端运行 JavaScript 代码。Node.js 基于 Chrome V8 引擎，具有高性能和高并发的特点，常用于构建高性能的 Web 应用、网络应用和微服务。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/myblog/2025/11/06/%E5%B7%A5%E5%85%B7/hexo/Nginx/</url>
    <content><![CDATA[<h1 id="Nginx-engine-x-HTTP和反向代理web服务器"><a href="#Nginx-engine-x-HTTP和反向代理web服务器" class="headerlink" title="Nginx (engine x) HTTP和反向代理web服务器"></a>Nginx (engine x) HTTP和反向代理web服务器</h1><ul>
<li>一、Nginx 概念<ul>
<li>1.1 起源与特点<ul>
<li>Nginx（发音为 “engine X”）是一个高性能的 HTTP 和反向代理服务器，由俄罗斯程序员伊戈尔·西索夫（Igor Sysoev）于 2002 年开发。其设计目标是处理高并发请求，具有以下特点：</li>
<li>高性能：能够处理大量并发连接，资源占用低。</li>
<li>高可用性：支持热部署和无缝升级。</li>
<li>模块化设计：支持多种模块扩展功能。</li>
<li>跨平台：支持 Linux、Unix、Windows 等多种操作系统。</li>
</ul>
</li>
<li>1.2 用途<ul>
<li>开源Web服务器：用于托管静态和动态网站。</li>
<li>反向代理：主要将请求转发到后端服务器，这个后端服务器可能是集群多台，但请求过来反向代理去了后端其中一台服务器。</li>
<li>负载均衡：分发流量到多个服务器。</li>
<li>内容缓存：缓存静态内容，提高响应速度。</li>
<li>API 网关：作为 API 的入口，处理请求路由和安全验证。</li>
</ul>
</li>
</ul>
</li>
<li>二、Nginx 的工作原理<ul>
<li>2.1 事件驱动架构<ul>
<li>Nginx 采用事件驱动的异步架构，其核心是基于非阻塞 I&#x2F;O 和多路复用技术。主要工作流程如下：</li>
<li>事件循环：Nginx 的工作进程通过事件循环不断监听和处理网络事件。</li>
<li>连接复用：支持 HTTP Keep-Alive，减少连接建立和关闭的开销。</li>
<li>非阻塞 I&#x2F;O：通过非阻塞方式读写数据，避免线程阻塞。</li>
</ul>
</li>
<li>2.2 请求处理流程<ul>
<li>接收请求：Nginx 工作进程接收客户端请求。</li>
<li>解析配置：根据配置文件决定如何处理请求。</li>
<li>模块处理：调用相应的模块处理请求（如静态文件处理、反向代理等）。</li>
<li>响应请求：将处理结果返回给客户端。</li>
</ul>
</li>
<li>2.3 模块化设计<ul>
<li>Nginx 的模块化设计使其功能高度可扩展。主要模块包括：</li>
<li>核心模块：负责基础功能，如事件处理、网络连接等。</li>
<li>HTTP 模块：处理 HTTP 请求，支持静态文件、CGI、FastCGI 等。</li>
<li>第三方模块：通过扩展实现更多功能，如认证、缓存等。</li>
</ul>
</li>
</ul>
</li>
<li>三、Nginx 的架构设计<ul>
<li>3.1 多级架构<ul>
<li>Nginx 的架构分为以下几个层次：</li>
<li>核心层：负责事件循环、连接管理等基础功能。</li>
<li>模块层：提供 HTTP、反向代理等功能。</li>
<li>网络层：处理网络通信和数据传输。</li>
</ul>
</li>
<li>3.2 进程模型<ul>
<li>Nginx 采用多进程模型，包括一个主进程和多个工作进程：</li>
<li>主进程：负责加载配置文件、管理工作进程等。</li>
<li>工作进程：处理客户端请求，数量通常与 CPU 核心数相同。</li>
</ul>
</li>
<li>3.3 线程池<ul>
<li>Nginx 支持线程池，用于处理耗时操作（如磁盘 I&#x2F;O），避免阻塞事件循环。</li>
</ul>
</li>
</ul>
</li>
<li>四、Nginx 的性能优化<ul>
<li>4.1 静态文件缓存<ul>
<li>缓存机制：通过 sendfile 和 tcp_nopush 等指令优化静态文件传输。</li>
<li>压缩传输：使用 gzip 压缩静态文件，减少传输数据量。</li>
</ul>
</li>
<li>4.2 负载均衡<ul>
<li>轮询策略：将请求均匀分配到多个后端服务器。</li>
<li>最少连接策略：优先将请求分配给连接数最少的服务器。</li>
<li>IP 哈希策略：根据客户端 IP 哈希分配请求，确保同一客户端的请求分配到同一服务器。</li>
</ul>
</li>
<li>4.3 反向代理与缓存<ul>
<li>反向代理：通过 proxy_pass 将请求转发到后端服务器。</li>
<li>缓存配置：使用 proxy_cache 配置缓存策略，减少后端服务器负载。</li>
</ul>
</li>
<li>4.4 连接优化<ul>
<li>Keep-Alive：通过 keepalive 指令复用连接，减少连接建立和关闭的开销。</li>
<li>连接超时：合理设置连接超时时间，避免资源浪费。</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>python编程语言</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/python/python/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/myblog/2025/11/06/%E5%B7%A5%E5%85%B7/hexo/tomcat/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><ul>
<li><p>Apache Tomcat是由Apache Software Foundation（ASF）开发的一个开源Java WEB应用服务器</p>
</li>
<li><p>加载类和资源的顺序如下：</p>
<ul>
<li>&#x2F;Web-INF&#x2F;classes</li>
<li>&#x2F;Web-INF&#x2F;lib&#x2F;*.jar</li>
<li>Bootstrap</li>
<li>System</li>
<li>$CATALINA_HOME&#x2F;common&#x2F;classes</li>
<li>$CATALINA_HOME&#x2F;common&#x2F;endores&#x2F;*.jar</li>
<li>$CATALINA_HOME&#x2F;common&#x2F;lib&#x2F;*.jar</li>
<li>$CATALINA_HOME&#x2F;shared&#x2F;classes</li>
<li>$CATALINA_HOME&#x2F;shared&#x2F;lib&#x2F;*.jar</li>
</ul>
</li>
<li><p>web.xml 配置标签</p>
<ul>
<li>servlet: 定义Servlet，包括Servlet名称、实现类、初始化参数等。</li>
<li>servlet-mapping-: 映射Servlet到一个或多个URL模式。<ul>
<li>url-pattern:配置指定路径映射Servlet<ul>
<li>如果错误的配置会导致jsp或html成接口输出成纯文本<a href="https://husama.github.io/2017/05/31/Spring-MVC%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-JSP%E6%9C%AA%E6%B8%B2%E6%9F%93-%E7%9B%B4%E6%8E%A5%E6%98%BE%E7%A4%BA%E6%BA%90%E7%A0%81.html">类似</a></li>
</ul>
</li>
</ul>
</li>
<li>filter: 定义过滤器，用于在请求处理链中执行过滤任务。</li>
<li>filter-mapping: 将过滤器应用到特定的URL模式。</li>
<li>listener: 定义事件监听器，用于响应应用生命周期事件。</li>
<li>session-config: 配置会话（Session）的超时时间。</li>
<li>welcome-file-list: 定义当请求URL为目录时，应该显示哪个欢迎文件。</li>
<li>error-page: 定义错误页面，用于处理特定错误码或异常类型。</li>
<li>security-constraint: 定义安全约束，用于限制对特定URL模式的访问。</li>
<li>login-config: 定义登录配置，用于指定验证方法和登录页面。</li>
<li>DefaultServlet控制缓存<ul>
<li>Tomcat默认不会为静态资源设置特定的缓存头</li>
<li>web.xml配置使用过滤器CacheControlFilter去设置浏览器缓存行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程语言(思维导图版)</title>
    <url>/myblog/2025/11/06/%E5%90%8E%E7%AB%AF/JAVA/Java%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%89%88/</url>
    <content><![CDATA[<div style="border: 2px solid white;
border-radius: 8px;
box-shadow: 0 0 15px rgba(0,0,0,0.15);">

<div class="markmap-wrap" 
      
      
    >
      <script type="application/json">{"content":"Java","children":[{"content":"&#x9762;&#x5411;&#x5bf9;&#x8c61;&#x7f16;&#x7a0b;&#x8bed;&#x8a00;","children":[{"content":"&#x662f;&#x4e00;&#x4e2a;&#x9762;&#x5411;&#x5bf9;&#x8c61;&#x7684;&#x8bed;&#x8a00;&#xff0c;&#x540c;&#x65f6;&#x57fa;&#x4e8e;JVM&#x865a;&#x62df;&#x673a;&#x652f;&#x6301;&#x8de8;&#x5e73;&#x53f0;&#x8fd0;&#x884c;&#x3002;","children":[],"payload":{"tag":"li","lines":"2,3"}},{"content":"&#x4e00;&#x6b21;&#x7f16;&#x8bd1;&#xff0c;&#x591a;&#x6b21;&#x8fd0;&#x884c;&#x3002;&#x5c5e;&#x4e8e;&#x534a;&#x7f16;&#x8bd1;&#x534a;&#x89e3;&#x91ca;&#x8bed;&#x8a00;&#x3002;","children":[],"payload":{"tag":"li","lines":"3,4"}}],"payload":{"tag":"li","lines":"1,4"}},{"content":"JVM","children":[{"content":"JVM(Java Virtual Machine) &#x5728;&#x7528;&#x6237;&#x5b89;&#x88c5;&#x73af;&#x5883;&#xff08;JRE&#xff09;&#x6216; Java &#x5f00;&#x53d1;&#x5de5;&#x5177;&#x5305;&#xff08;JDK&#xff09;&#x65f6;&#x4f1a;&#x81ea;&#x5e26;JVM&#x3002;","children":[],"payload":{"tag":"li","lines":"5,6"}},{"content":"&#x7f16;&#x8bd1;","children":[{"content":".java&#x6e90;&#x4ee3;&#x7801;&#x6587;&#x4ef6;&#x901a;&#x8fc7;Java&#x7f16;&#x8bd1;&#x5668;&#xff08;javac&#xff09;&#x8fdb;&#x884c;&#x7f16;&#x8bd1;&#x6210;.class&#x5b57;&#x8282;&#x7801;&#x6587;&#x4ef6;","children":[],"payload":{"tag":"li","lines":"7,8"}}],"payload":{"tag":"li","lines":"6,8"}},{"content":"&#x8fd0;&#x884c;","children":[{"content":"ClassLoader&#x7c7b;&#x52a0;&#x8f7d;","children":[{"content":".class&#x6587;&#x4ef6;&#x5bf9;&#x5e94;&#x9762;&#x5411;&#x7684;&#x662f;java&#x865a;&#x62df;&#x673a;&#xff08;JVM&#xff09;&#x7684;&#x6307;&#x4ee4;&#x96c6;&#x8fd0;&#x884c;","children":[],"payload":{"tag":"li","lines":"10,11"}},{"content":"&#x7c7b;&#x52a0;&#x8f7d;&#x5668;ClassLoader&#x5c06;.class&#x6587;&#x4ef6;&#x52a0;&#x8f7d;&#x5230;JVM&#x8bbe;&#x7f6e;&#x7684;&#x5185;&#x5b58;&#x5f53;&#x4e2d;&#x3002;&#x5e76;&#x5c06;&#x5176;&#x8f6c;&#x6362;&#x4e3a;java.lang.Class&#x5bf9;&#x8c61;&#x3002;&#x540c;&#x65f6;&#x652f;&#x6301;&#x52a8;&#x6001;&#x52a0;&#x8f7d;&#x7c7b;&#x3002;&#x53cd;&#x5c04;&#x673a;&#x5236;&#x57fa;&#x4e8e;&#x8fd9;&#x4e2a;&#x7279;&#x70b9;&#x5b9e;&#x73b0;&#x3002;","children":[],"payload":{"tag":"li","lines":"11,12"}}],"payload":{"tag":"li","lines":"9,12"}},{"content":"&#x65b9;&#x6cd5;&#x533a;&#xff08;Method Area&#xff09;","children":[{"content":"&#x5728;JDK1.8&#x7248;&#x672c;&#x5e9f;&#x5f03;&#x4e86;&#x6c38;&#x4e45;&#x4ee3;&#xff0c;&#x66ff;&#x4ee3;&#x7684;&#x662f;&#x5143;&#x7a7a;&#x95f4;&#xff08;MetaSpace&#xff09;&#xff0c;&#x5143;&#x7a7a;&#x95f4;&#x4e0e;&#x6c38;&#x4e45;&#x4ee3;&#x4e0a;&#x7c7b;&#x4f3c;&#xff0c;&#x90fd;&#x662f;&#x65b9;&#x6cd5;&#x533a;&#x7684;&#x5b9e;&#x73b0;&#xff0c;&#x4ed6;&#x4eec;&#x6700;&#x5927;&#x533a;&#x522b;&#x662f;&#xff1a;&#x5143;&#x7a7a;&#x95f4;&#x5e76;&#x4e0d;&#x5728;JVM&#x4e2d;&#xff0c;&#x800c;&#x662f;&#x4f7f;&#x7528;&#x672c;&#x5730;&#x5185;&#x5b58;&#x3002;","children":[],"payload":{"tag":"li","lines":"13,14"}},{"content":"&#x7c7b;&#x578b;&#x4fe1;&#x606f;&#xff1a;&#x5b58;&#x50a8;&#x4e86;&#x6bcf;&#x4e2a;&#x52a0;&#x8f7d;&#x7684;&#x7c7b;&#x7684;&#x5168;&#x540d;&#x3001;&#x7236;&#x7c7b;&#x5168;&#x540d;&#x3001;&#x4fee;&#x9970;&#x7b26;&#x3001;&#x76f4;&#x63a5;&#x63a5;&#x53e3;&#x7d22;&#x5f15;&#x7b49;&#x4fe1;&#x606f;&#x3002;","children":[],"payload":{"tag":"li","lines":"14,15"}},{"content":"&#x5e38;&#x91cf;&#x6c60;&#xff1a;&#x5305;&#x62ec;&#x7c7b;&#x4e2d;&#x6240;&#x6709;&#x7684;&#x5e38;&#x91cf;&#x4fe1;&#x606f;&#xff0c;&#x5982;&#x5b57;&#x7b26;&#x4e32;&#x5b57;&#x9762;&#x91cf;&#x3001;&#x6570;&#x503c;&#x5b57;&#x9762;&#x91cf;&#x7b49;&#x3002;","children":[],"payload":{"tag":"li","lines":"15,16"}},{"content":"&#x5b57;&#x6bb5;&#x4fe1;&#x606f;&#xff1a;&#x5b58;&#x50a8;&#x4e86;&#x7c7b;&#x4e2d;&#x6240;&#x6709;&#x5b57;&#x6bb5;&#x7684;&#x540d;&#x79f0;&#x3001;&#x7c7b;&#x578b;&#x3001;&#x4fee;&#x9970;&#x7b26;&#x7b49;&#x4fe1;&#x606f;&#x3002;","children":[],"payload":{"tag":"li","lines":"16,17"}},{"content":"&#x65b9;&#x6cd5;&#x4fe1;&#x606f;&#xff1a;&#x5b58;&#x50a8;&#x4e86;&#x7c7b;&#x4e2d;&#x6240;&#x6709;&#x65b9;&#x6cd5;&#x7684;&#x540d;&#x79f0;&#x3001;&#x8fd4;&#x56de;&#x7c7b;&#x578b;&#x3001;&#x53c2;&#x6570;&#x3001;&#x4fee;&#x9970;&#x7b26;&#x7b49;&#x4fe1;&#x606f;&#xff0c;&#x4ee5;&#x53ca;&#x65b9;&#x6cd5;&#x7684;&#x5b57;&#x8282;&#x7801;&#x3001;&#x64cd;&#x4f5c;&#x6570;&#x6808;&#x3001;&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x8868;&#x5927;&#x5c0f;&#x7b49;&#x3002;","children":[],"payload":{"tag":"li","lines":"17,18"}},{"content":"&#x7c7b;&#x53d8;&#x91cf;&#xff1a;&#x5373;&#x9759;&#x6001;&#x53d8;&#x91cf;&#xff0c;&#x4e0e;&#x7c7b;&#x76f8;&#x5173;&#x8054;&#xff0c;&#x968f;&#x7740;&#x7c7b;&#x7684;&#x52a0;&#x8f7d;&#x800c;&#x52a0;&#x8f7d;&#xff0c;&#x7531;&#x7c7b;&#x7684;&#x6240;&#x6709;&#x5b9e;&#x4f8b;&#x5171;&#x4eab;&#x3002;","children":[],"payload":{"tag":"li","lines":"18,19"}},{"content":"&#x8fd0;&#x884c;&#x65f6;&#x5e38;&#x91cf;&#x6c60;&#xff1a;&#x7c7b;&#x52a0;&#x8f7d;&#x540e;&#xff0c;&#x5e38;&#x91cf;&#x6c60;&#x8868;&#x4e2d;&#x7684;&#x5185;&#x5bb9;&#x4f1a;&#x5b58;&#x653e;&#x5230;&#x65b9;&#x6cd5;&#x533a;&#x7684;&#x8fd0;&#x884c;&#x65f6;&#x5e38;&#x91cf;&#x6c60;&#x4e2d;&#x3002;","children":[],"payload":{"tag":"li","lines":"19,20"}}],"payload":{"tag":"li","lines":"12,20"}},{"content":"&#x5806;&#xff08;Heap&#xff09;","children":[{"content":"JVM&#x5806;&#x5185;&#x5b58;&#x5e38;&#x7528;&#x53c2;&#x6570;","children":[{"content":"-Xms\t&#x5806;&#x5185;&#x5b58;&#x521d;&#x59cb;&#x5927;&#x5c0f;&#xff0c;&#x5355;&#x4f4d;m&#x3001;g","children":[],"payload":{"tag":"li","lines":"22,23"}},{"content":"-Xmx&#xff08;MaxHeapSize&#xff09;\t&#x5806;&#x5185;&#x5b58;&#x6700;&#x5927;&#x5141;&#x8bb8;&#x5927;&#x5c0f;&#xff0c;&#x4e00;&#x822c;&#x4e0d;&#x8981;&#x5927;&#x4e8e;&#x7269;&#x7406;&#x5185;&#x5b58;&#x7684;80%","children":[],"payload":{"tag":"li","lines":"23,24"}},{"content":"-XX:PermSize\t&#x975e;&#x5806;&#x5185;&#x5b58;&#x521d;&#x59cb;&#x5927;&#x5c0f;&#xff0c;&#x4e00;&#x822c;&#x5e94;&#x7528;&#x8bbe;&#x7f6e;&#x521d;&#x59cb;&#x5316;200m&#xff0c;&#x6700;&#x5927;1024m&#x5c31;&#x591f;&#x4e86; &#xff08;&#x5728;JDK1.8&#x7248;&#x672c;&#x540e;&#x5e9f;&#x5f03;&#xff09;","children":[],"payload":{"tag":"li","lines":"24,25"}},{"content":"-XX:MaxPermSize\t&#x975e;&#x5806;&#x5185;&#x5b58;&#x6700;&#x5927;&#x5141;&#x8bb8;&#x5927;&#x5c0f; &#xff08;&#x5728;JDK1.8&#x7248;&#x672c;&#x540e;&#x5e9f;&#x5f03;&#xff09;","children":[],"payload":{"tag":"li","lines":"25,26"}},{"content":"-XX:NewSize&#xff08;-Xns&#xff09;\t&#x5e74;&#x8f7b;&#x4ee3;&#x5185;&#x5b58;&#x521d;&#x59cb;&#x5927;&#x5c0f;","children":[],"payload":{"tag":"li","lines":"26,27"}},{"content":"-XX:MaxNewSize&#xff08;-Xmn&#xff09;\t&#x5e74;&#x8f7b;&#x4ee3;&#x5185;&#x5b58;&#x6700;&#x5927;&#x5141;&#x8bb8;&#x5927;&#x5c0f;&#xff0c;&#x4e5f;&#x53ef;&#x4ee5;&#x7f29;&#x5199;","children":[],"payload":{"tag":"li","lines":"27,28"}},{"content":"-XX:SurvivorRatio=8\t&#x5e74;&#x8f7b;&#x4ee3;&#x4e2d;Eden&#x533a;&#x4e0e;Survivor&#x533a;&#x7684;&#x5bb9;&#x91cf;&#x6bd4;&#x4f8b;&#x503c;&#xff0c;&#x9ed8;&#x8ba4;&#x4e3a;8&#xff0c;&#x5373;8:1","children":[],"payload":{"tag":"li","lines":"28,29"}},{"content":"-Xss\t&#x5806;&#x6808;&#x5185;&#x5b58;&#x5927;&#x5c0f;","children":[],"payload":{"tag":"li","lines":"29,30"}}],"payload":{"tag":"li","lines":"21,30"}},{"content":"&#x5806;&#x662f;JVM&#x4e2d;&#x5185;&#x5b58;&#x6700;&#x5927;&#x7684;&#x4e00;&#x5757;&#xff0c;&#x540c;&#x65f6;&#x4e5f;&#x662f;&#x5783;&#x573e;&#x6536;&#x96c6;&#x5668;&#xff08;Garbage Collector&#xff09;&#x7ba1;&#x7406;&#x7684;&#x4e3b;&#x8981;&#x533a;&#x57df;&#xff0c;&#x8d1f;&#x8d23;&#x56de;&#x6536;&#x8fd9;&#x4e9b;&#x5bf9;&#x8c61;&#x3002;","children":[],"payload":{"tag":"li","lines":"30,31"}},{"content":"&#x4e3b;&#x8981;&#x4f5c;&#x7528;&#x5b58;&#x653e;&#x5bf9;&#x8c61;&#x5b9e;&#x4f8b;&#x6570;&#x7ec4;&#x6570;&#x636e;&#x7b49;&#x3002;&#x6240;&#x6709;&#x7ebf;&#x7a0b;&#x5171;&#x4eab;&#x7684;&#x5185;&#x5b58;&#x533a;&#x57df;","children":[],"payload":{"tag":"li","lines":"31,32"}},{"content":"&#x9700;&#x8981;&#x6ce8;&#x610f;&#x7ba1;&#x7406;&#x597d;&#x5185;&#x5b58;,&#x5426;&#x5219;&#x53ef;&#x80fd;&#x5f15;&#x8d77;&#x5185;&#x5b58;&#x6ea2;&#x51fa;&#x95ee;&#x9898;&#x3002;","children":[],"payload":{"tag":"li","lines":"32,33"}}],"payload":{"tag":"li","lines":"20,33"}},{"content":"Java&#x865a;&#x62df;&#x673a;&#x6808;&#xff08;Java Virtual Machine Stack&#xff09;","children":[{"content":"JVM&#x6808;&#x7684;&#x5185;&#x5b58;&#x5206;&#x914d;&#x5728;JVM&#x542f;&#x52a8;&#x65f6;&#x786e;&#x5b9a;&#xff0c;&#x901a;&#x5e38;&#x53ef;&#x4ee5;&#x901a;&#x8fc7;-Xss&#x53c2;&#x6570;&#x8bbe;&#x7f6e;&#x6bcf;&#x4e2a;&#x7ebf;&#x7a0b;&#x7684;&#x6808;&#x5927;&#x5c0f;&#x3002;","children":[],"payload":{"tag":"li","lines":"34,35"}},{"content":"&#x6bcf;&#x4e2a;&#x7ebf;&#x7a0b;&#x90fd;&#x6709;&#x4e00;&#x4e2a;&#x79c1;&#x6709;&#x7684;&#x6808;&#xff0c;&#x7528;&#x4e8e;&#x5b58;&#x50a8;&#x65b9;&#x6cd5;&#x8c03;&#x7528;&#x65f6;&#x7684;&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x3001;&#x64cd;&#x4f5c;&#x6570;&#x6808;&#x548c;&#x52a8;&#x6001;&#x94fe;&#x63a5;&#x4fe1;&#x606f;","children":[],"payload":{"tag":"li","lines":"35,36"}},{"content":"JVM&#x6808;&#x7684;&#x751f;&#x547d;&#x5468;&#x671f;&#x4e0e;&#x7ebf;&#x7a0b;&#x7684;&#x751f;&#x547d;&#x5468;&#x671f;&#x76f8;&#x540c;&#x3002;&#x7ebf;&#x7a0b;&#x5f00;&#x59cb;&#x65f6;&#xff0c;JVM&#x6808;&#x88ab;&#x521b;&#x5efa;&#xff1b;&#x7ebf;&#x7a0b;&#x7ed3;&#x675f;&#x65f6;&#xff0c;JVM&#x6808;&#x88ab;&#x9500;&#x6bc1;&#x3002;","children":[],"payload":{"tag":"li","lines":"36,37"}},{"content":"&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x8868;&#xff08;Local Variable Table&#xff09;","children":[{"content":"&#x7528;&#x4e8e;&#x5b58;&#x50a8;&#x65b9;&#x6cd5;&#x7684;&#x53c2;&#x6570;&#x548c;&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x3002;","children":[],"payload":{"tag":"li","lines":"38,39"}},{"content":"&#x6bcf;&#x4e2a;&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x5360;&#x7528;&#x4e00;&#x4e2a;&#x69fd;&#xff08;slot&#xff09;&#xff0c;&#x69fd;&#x7684;&#x5927;&#x5c0f;&#x4e3a;32&#x4f4d;&#x3002;","children":[],"payload":{"tag":"li","lines":"39,40"}},{"content":"&#x5c40;&#x90e8;&#x53d8;&#x91cf;&#x8868;&#x7684;&#x5927;&#x5c0f;&#x5728;&#x65b9;&#x6cd5;&#x7f16;&#x8bd1;&#x65f6;&#x786e;&#x5b9a;&#x3002;","children":[],"payload":{"tag":"li","lines":"40,41"}}],"payload":{"tag":"li","lines":"37,41"}},{"content":"&#x64cd;&#x4f5c;&#x6570;&#x6808;&#xff08;Operand Stack&#xff09;","children":[{"content":"&#x7528;&#x4e8e;&#x5b58;&#x50a8;&#x64cd;&#x4f5c;&#x6570;&#x548c;&#x4e2d;&#x95f4;&#x7ed3;&#x679c;&#x3002;","children":[],"payload":{"tag":"li","lines":"42,43"}},{"content":"&#x64cd;&#x4f5c;&#x6570;&#x6808;&#x662f;&#x4e00;&#x4e2a;&#x540e;&#x8fdb;&#x5148;&#x51fa;&#x7684;&#x6808;&#xff0c;&#x5176;&#x5927;&#x5c0f;&#x5728;&#x65b9;&#x6cd5;&#x6267;&#x884c;&#x65f6;&#x52a8;&#x6001;&#x53d8;&#x5316;&#x3002;","children":[],"payload":{"tag":"li","lines":"43,44"}}],"payload":{"tag":"li","lines":"41,44"}},{"content":"&#x5e27;&#x6570;&#x636e;&#x533a;&#xff08;Frame Data Area&#xff09;","children":[{"content":"&#x5305;&#x542b;&#x65b9;&#x6cd5;&#x7684;&#x8fd0;&#x884c;&#x65f6;&#x5e38;&#x91cf;&#x6c60;&#x5f15;&#x7528;&#x3001;&#x65b9;&#x6cd5;&#x7684;&#x8fd4;&#x56de;&#x5730;&#x5740;&#x3001;&#x5f02;&#x5e38;&#x5904;&#x7406;&#x8868;&#x7b49;&#x4fe1;&#x606f;&#x3002;","children":[],"payload":{"tag":"li","lines":"45,46"}},{"content":"&#x65b9;&#x6cd5;&#x8fd4;&#x56de;&#x5730;&#x5740;&#xff08;Return Address&#xff09;-&#x5e27;&#x6570;&#x636e;&#x533a;&#x5b58;&#x50a8;&#x4e86;&#x65b9;&#x6cd5;&#x8fd4;&#x56de;&#x65f6;&#x9700;&#x8981;&#x8df3;&#x8f6c;&#x5230;&#x7684;&#x5730;&#x5740;&#x3002;&#x5f53;&#x65b9;&#x6cd5;&#x6267;&#x884c;&#x5b8c;&#x6210;&#xff08;&#x65e0;&#x8bba;&#x662f;&#x6b63;&#x5e38;&#x8fd4;&#x56de;&#x8fd8;&#x662f;&#x5f02;&#x5e38;&#x7ec8;&#x6b62;&#xff09;&#xff0c;JVM&#x4f1a;&#x6839;&#x636e;&#x8fd9;&#x4e2a;&#x8fd4;&#x56de;&#x5730;&#x5740;&#x8df3;&#x56de;&#x5230;&#x8c03;&#x7528;&#x8be5;&#x65b9;&#x6cd5;&#x7684;&#x4e0a;&#x4e00;&#x4e2a;&#x6808;&#x5e27;","children":[],"payload":{"tag":"li","lines":"46,47"}},{"content":"&#x52a8;&#x6001;&#x94fe;&#x63a5;&#xff08;Dynamic Linking&#xff09;&#x5e27;&#x6570;&#x636e;&#x533a;&#x652f;&#x6301;&#x52a8;&#x6001;&#x94fe;&#x63a5;&#x673a;&#x5236;&#x3002;&#x5f53;&#x65b9;&#x6cd5;&#x8c03;&#x7528;&#x5176;&#x4ed6;&#x65b9;&#x6cd5;&#x6216;&#x8bbf;&#x95ee;&#x5b57;&#x6bb5;&#x65f6;&#xff0c;JVM&#x9700;&#x8981;&#x89e3;&#x6790;&#x7b26;&#x53f7;&#x5f15;&#x7528;&#x3002;&#x5982;&#x679c;&#x8fd9;&#x4e9b;&#x5f15;&#x7528;&#x5c1a;&#x672a;&#x89e3;&#x6790;&#xff0c;JVM&#x4f1a;&#x5728;&#x8fd0;&#x884c;&#x65f6;&#x52a8;&#x6001;&#x89e3;&#x6790;&#x5b83;&#x4eec;","children":[],"payload":{"tag":"li","lines":"47,48"}},{"content":"&#x5f02;&#x5e38;&#x8868;&#x5f15;&#x7528;&#xff08;Exception Table Reference&#xff09;&#x5e27;&#x6570;&#x636e;&#x533a;&#x8fd8;&#x5305;&#x542b;&#x4e00;&#x4e2a;&#x5bf9;&#x5f02;&#x5e38;&#x8868;&#xff08;Exception Table&#xff09;&#x7684;&#x5f15;&#x7528;&#x3002;&#x5f02;&#x5e38;&#x8868;&#x5b9a;&#x4e49;&#x4e86;&#x65b9;&#x6cd5;&#x4e2d;&#x54ea;&#x4e9b;&#x5b57;&#x8282;&#x7801;&#x8303;&#x56f4;&#x88ab;&#x54ea;&#x4e9b;catch&#x5b50;&#x53e5;&#x4fdd;&#x62a4;&#x3002;&#x5f53;&#x65b9;&#x6cd5;&#x629b;&#x51fa;&#x5f02;&#x5e38;&#x65f6;&#xff0c;JVM&#x4f1a;&#x901a;&#x8fc7;&#x5f02;&#x5e38;&#x8868;&#x6765;&#x786e;&#x5b9a;&#x662f;&#x5426;&#x80fd;&#x627e;&#x5230;&#x5339;&#x914d;&#x7684;catch&#x5b50;&#x53e5;&#x6765;&#x5904;&#x7406;&#x5f02;&#x5e38;","children":[],"payload":{"tag":"li","lines":"48,49"}},{"content":"&#x5e38;&#x91cf;&#x6c60;&#x5f15;&#x7528;&#xff08;Constant Pool Reference&#xff09;&#x5e27;&#x6570;&#x636e;&#x533a;&#x5305;&#x542b;&#x4e00;&#x4e2a;&#x5bf9;&#x5f53;&#x524d;&#x65b9;&#x6cd5;&#x6240;&#x5c5e;&#x7c7b;&#x7684;&#x8fd0;&#x884c;&#x65f6;&#x5e38;&#x91cf;&#x6c60;&#x7684;&#x5f15;&#x7528;&#x3002;&#x8fd9;&#x4e2a;&#x5f15;&#x7528;&#x7528;&#x4e8e;&#x652f;&#x6301;&#x5e38;&#x91cf;&#x6c60;&#x89e3;&#x6790;&#xff0c;&#x5373;&#x5728;&#x6267;&#x884c;&#x5b57;&#x8282;&#x7801;&#x6307;&#x4ee4;&#x65f6;&#xff0c;JVM&#x53ef;&#x4ee5;&#x901a;&#x8fc7;&#x8fd9;&#x4e2a;&#x5f15;&#x7528;&#x8bbf;&#x95ee;&#x5e38;&#x91cf;&#x6c60;&#x4e2d;&#x7684;&#x7b26;&#x53f7;&#x5f15;&#x7528;","children":[],"payload":{"tag":"li","lines":"49,50"}}],"payload":{"tag":"li","lines":"44,50"}}],"payload":{"tag":"li","lines":"33,50"}},{"content":"&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#xff08;Program Counter Register&#xff09;","children":[{"content":"&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#x662f;&#x7ebf;&#x7a0b;&#x79c1;&#x6709;&#x7684;&#xff0c;&#x6bcf;&#x4e2a;&#x7ebf;&#x7a0b;&#x90fd;&#x6709;&#x81ea;&#x5df1;&#x7684;&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#x3002;&#x7ebf;&#x7a0b;&#x4e4b;&#x95f4;&#x7684;&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#x4e92;&#x4e0d;&#x5e72;&#x6270;","children":[],"payload":{"tag":"li","lines":"51,52"}},{"content":"&#x8bb0;&#x5f55;&#x5f53;&#x524d;&#x7ebf;&#x7a0b;&#x6240;&#x6267;&#x884c;&#x7684;&#x5b57;&#x8282;&#x7801;&#x6307;&#x4ee4;&#x5730;&#x5740;","children":[],"payload":{"tag":"li","lines":"52,53"}},{"content":"&#x5f53;&#x4e00;&#x4e2a;&#x65b9;&#x6cd5;&#x88ab;&#x8c03;&#x7528;&#x65f6;&#xff0c;&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#x4f1a;&#x4fdd;&#x5b58;&#x65b9;&#x6cd5;&#x7684;&#x5165;&#x53e3;&#x5730;&#x5740;&#x3002;&#x5f53;&#x65b9;&#x6cd5;&#x6267;&#x884c;&#x5b8c;&#x6bd5;&#x540e;&#xff0c;&#x7a0b;&#x5e8f;&#x8ba1;&#x6570;&#x5668;&#x4f1a;&#x6062;&#x590d;&#x5230;&#x8c03;&#x7528;&#x65b9;&#x6cd5;&#x65f6;&#x7684;&#x5730;&#x5740;&#xff0c;&#x4ece;&#x800c;&#x5b9e;&#x73b0;&#x65b9;&#x6cd5;&#x7684;&#x8fd4;&#x56de;","children":[],"payload":{"tag":"li","lines":"53,54"}}],"payload":{"tag":"li","lines":"50,54"}},{"content":"&#x672c;&#x5730;&#x65b9;&#x6cd5;&#x6808;&#xff08;Native Method Stack&#xff09;","children":[{"content":"&#x548c;Java&#x865a;&#x62df;&#x673a;&#x6808;&#x57fa;&#x672c;&#x4e00;&#x81f4;&#xff0c;&#x672c;&#x5730;&#x65b9;&#x6cd5;&#x6808;&#x7528;&#x4e8e;&#x652f;&#x6301;&#x672c;&#x5730;&#x65b9;&#x6cd5;&#xff08;&#x5373;&#x975e;Java&#x8bed;&#x8a00;&#x7f16;&#x5199;&#x7684;&#x4ee3;&#x7801;&#xff0c;&#x5982;C&#x6216;C++&#x4ee3;&#x7801;&#xff09;&#x7684;&#x6267;&#x884c;&#x3002;&#x5f53;Java&#x7a0b;&#x5e8f;&#x901a;&#x8fc7;JNI&#xff08;Java Native Interface&#xff09;&#x8c03;&#x7528;&#x672c;&#x5730;&#x65b9;&#x6cd5;&#x65f6;&#xff0c;&#x672c;&#x5730;&#x65b9;&#x6cd5;&#x6808;&#x4f1a;&#x7ba1;&#x7406;&#x8fd9;&#x4e9b;&#x672c;&#x5730;&#x65b9;&#x6cd5;&#x7684;&#x6267;&#x884c;&#x72b6;&#x6001;&#x3002;","children":[],"payload":{"tag":"li","lines":"55,56"}}],"payload":{"tag":"li","lines":"54,56"}},{"content":"&#x6267;&#x884c;&#x5f15;&#x64ce;&#xff08;Execution Engine&#xff09;","children":[{"content":"&#x8d1f;&#x8d23;&#x5c06;&#x5b57;&#x8282;&#x7801;&#x6307;&#x4ee4;&#x89e3;&#x91ca;/&#x7f16;&#x8bd1;&#x4e3a;&#x5bf9;&#x5e94;&#x5e73;&#x53f0;&#x4e0a;&#x7684;&#x672c;&#x5730;&#x673a;&#x5668;&#x6307;&#x4ee4;,&#x6267;&#x884c;&#x5f15;&#x64ce;&#x5145;&#x5f53;&#x4e86;&#x5c06;&#x9ad8;&#x7ea7;&#x8bed;&#x8a00;&#x7ffb;&#x8bd1;&#x4e3a;&#x673a;&#x5668;&#x8bed;&#x8a00;&#x7684;&#x8bd1;&#x8005;&#x3002;","children":[],"payload":{"tag":"li","lines":"57,58"}},{"content":"&#x89e3;&#x91ca;&#x5668;&#xff08;Interpreter&#xff09;","children":[{"content":"&#x9010;&#x6761;&#x89e3;&#x91ca;&#x5b57;&#x8282;&#x7801;&#x6307;&#x4ee4;&#xff0c;&#x5e76;&#x5c06;&#x5176;&#x8f6c;&#x6362;&#x4e3a;&#x76f8;&#x5e94;&#x7684;&#x673a;&#x5668;&#x6307;&#x4ee4;&#x6267;&#x884c;&#x3002;&#x8fd9;&#x662f;&#x6700;&#x57fa;&#x672c;&#x7684;&#x6267;&#x884c;&#x65b9;&#x5f0f;&#xff0c;&#x7b80;&#x5355;&#x4f46;&#x6548;&#x7387;&#x8f83;&#x4f4e;&#x3002;","children":[],"payload":{"tag":"li","lines":"59,60"}}],"payload":{"tag":"li","lines":"58,60"}},{"content":"&#x5373;&#x65f6;&#x7f16;&#x8bd1;&#x5668;&#xff08;JIT Compiler&#xff09;","children":[{"content":"&#x5c06;&#x9891;&#x7e41;&#x6267;&#x884c;&#x7684;&#x5b57;&#x8282;&#x7801;&#x7f16;&#x8bd1;&#x4e3a;&#x672c;&#x5730;&#x673a;&#x5668;&#x7801;&#xff0c;&#x4ee5;&#x63d0;&#x9ad8;&#x6267;&#x884c;&#x901f;&#x5ea6;&#x3002;JIT&#x7f16;&#x8bd1;&#x5668;&#x5728;&#x8fd0;&#x884c;&#x65f6;&#x5bf9;&#x70ed;&#x70b9;&#x4ee3;&#x7801;&#x8fdb;&#x884c;&#x4f18;&#x5316;&#x7f16;&#x8bd1;&#xff0c;&#x63d0;&#x5347;&#x6027;&#x80fd;&#x3002;","children":[],"payload":{"tag":"li","lines":"61,62"}}],"payload":{"tag":"li","lines":"60,62"}},{"content":"&#x5783;&#x573e;&#x56de;&#x6536;&#x5668;&#xff08;GC&#xff09;","children":[{"content":"Java&#x8bed;&#x8a00;&#x7684;&#x6838;&#x5fc3;&#x6280;&#x672f;&#x7279;&#x70b9;","children":[],"payload":{"tag":"li","lines":"63,64"}},{"content":"&#x548c;C++&#x76f8;&#x6bd4;&#xff0c;&#x4f1a;&#x81ea;&#x52a8;&#x56de;&#x6536;&#x4e0d;&#x518d;&#x4f7f;&#x7528;&#x7684;&#x5bf9;&#x8c61;&#xff0c;&#x91ca;&#x653e;&#x5185;&#x5b58;&#x8d44;&#x6e90;&#x3002;&#x9632;&#x6b62;&#x5bf9;&#x8c61;&#x5360;&#x7528;&#x5185;&#x5b58;&#x8fc7;&#x591a;&#xff0c;&#x5bfc;&#x81f4;&#x5185;&#x5b58;&#x6ea2;&#x51fa;&#x548c;&#x5361;&#x987f;&#x3002;","children":[],"payload":{"tag":"li","lines":"64,65"}},{"content":"&#x4ee5;&#x4e0b;&#x662f;&#x5404;&#x4e2a;&#x7248;&#x672c;&#x7684;&#x56de;&#x6536;&#x5668;","children":[{"content":"JDK8:Parallel Scavenge&#xff08;&#x65b0;&#x751f;&#x4ee3;&#xff09;+ Parallel Old&#xff08;&#x8001;&#x5e74;&#x4ee3;&#xff09;","children":[],"payload":{"tag":"li","lines":"66,67"}},{"content":"JDK9&#x5230;JDK21&#xff1a;G1&#xff08;Garbage-First&#xff09;","children":[],"payload":{"tag":"li","lines":"67,68"}},{"content":"JDK11&#x540e;&#x589e;&#x52a0;&#x4e86;&#xff1a;ZGC&#xff08;Z Garbage Collector&#xff09;&#xff0c;&#x4f46;&#x4e0d;&#x662f;&#x9ed8;&#x8ba4;&#x5f00;&#x542f;","children":[],"payload":{"tag":"li","lines":"68,69"}}],"payload":{"tag":"li","lines":"65,69"}}],"payload":{"tag":"li","lines":"62,69"}}],"payload":{"tag":"li","lines":"56,69"}}],"payload":{"tag":"li","lines":"8,69"}}],"payload":{"tag":"li","lines":"4,69"}}],"payload":{"tag":"li","lines":"0,69"}}</script>
      <script type="application/json">{}</script>
    </div>

</div>

<style>
.markmap {
  --markmap-text-color: #faf9f8;
}
</style>

<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程语言</title>
    <url>/myblog/2025/11/07/%E5%90%8E%E7%AB%AF/JAVA/Java/</url>
    <content><![CDATA[<h1 id="Java-面向对象编程语言"><a href="#Java-面向对象编程语言" class="headerlink" title="Java 面向对象编程语言"></a>Java 面向对象编程语言</h1><ul>
<li>是一个面向对象的语言，同时基于JVM虚拟机支持跨平台运行。</li>
<li>一次编译，多次运行。属于半编译半解释语言。</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM-Java-Virtual-Machine-在用户安装环境（JRE）或-Java-开发工具包（JDK）时会自带JVM。"><a href="#JVM-Java-Virtual-Machine-在用户安装环境（JRE）或-Java-开发工具包（JDK）时会自带JVM。" class="headerlink" title="JVM(Java Virtual Machine) 在用户安装环境（JRE）或 Java 开发工具包（JDK）时会自带JVM。"></a>JVM(Java Virtual Machine) 在用户安装环境（JRE）或 Java 开发工具包（JDK）时会自带JVM。</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>.java源代码文件通过Java编译器（javac）进行编译成.class字节码文件</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ClassLoader类加载"><a href="#ClassLoader类加载" class="headerlink" title="ClassLoader类加载"></a>ClassLoader类加载</h3><ul>
<li>.class文件对应面向的是java虚拟机（JVM）的指令集运行</li>
<li>类加载器ClassLoader将.class文件加载到JVM设置的内存当中。并将其转换为java.lang.Class对象。同时支持动态加载类。反射机制基于这个特点实现。</li>
</ul>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><ul>
<li>在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。</li>
<li>类型信息：存储了每个加载的类的全名、父类全名、修饰符、直接接口索引等信息。</li>
<li>常量池：包括类中所有的常量信息，如字符串字面量、数值字面量等。</li>
<li>字段信息：存储了类中所有字段的名称、类型、修饰符等信息。</li>
<li>方法信息：存储了类中所有方法的名称、返回类型、参数、修饰符等信息，以及方法的字节码、操作数栈、局部变量表大小等。</li>
<li>类变量：即静态变量，与类相关联，随着类的加载而加载，由类的所有实例共享。</li>
<li>运行时常量池：类加载后，常量池表中的内容会存放到方法区的运行时常量池中。</li>
</ul>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><ul>
<li>JVM堆内存常用参数<ul>
<li>-Xms	堆内存初始大小，单位m、g</li>
<li>-Xmx（MaxHeapSize）	堆内存最大允许大小，一般不要大于物理内存的80%</li>
<li>-XX:PermSize	非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了 （在JDK1.8版本后废弃）</li>
<li>-XX:MaxPermSize	非堆内存最大允许大小 （在JDK1.8版本后废弃）</li>
<li>-XX:NewSize（-Xns）	年轻代内存初始大小</li>
<li>-XX:MaxNewSize（-Xmn）	年轻代内存最大允许大小，也可以缩写</li>
<li>-XX:SurvivorRatio&#x3D;8	年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</li>
<li>-Xss	堆栈内存大小</li>
</ul>
</li>
<li>堆是JVM中内存最大的一块，同时也是垃圾收集器（Garbage Collector）管理的主要区域，负责回收这些对象。</li>
<li>主要作用存放对象实例数组数据等。所有线程共享的内存区域</li>
<li>需要注意管理好内存,否则可能引起内存溢出问题。</li>
</ul>
<h3 id="Java虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stack）"></a>Java虚拟机栈（Java Virtual Machine Stack）</h3><ul>
<li>JVM栈的内存分配在JVM启动时确定，通常可以通过-Xss参数设置每个线程的栈大小。</li>
<li>每个线程都有一个私有的栈，用于存储方法调用时的局部变量、操作数栈和动态链接信息</li>
<li>JVM栈的生命周期与线程的生命周期相同。线程开始时，JVM栈被创建；线程结束时，JVM栈被销毁。</li>
<li>局部变量表（Local Variable Table）<ul>
<li>用于存储方法的参数和局部变量。</li>
<li>每个局部变量占用一个槽（slot），槽的大小为32位。</li>
<li>局部变量表的大小在方法编译时确定。</li>
</ul>
</li>
<li>操作数栈（Operand Stack）<ul>
<li>用于存储操作数和中间结果。</li>
<li>操作数栈是一个后进先出的栈，其大小在方法执行时动态变化。</li>
</ul>
</li>
<li>帧数据区（Frame Data Area）<ul>
<li>包含方法的运行时常量池引用、方法的返回地址、异常处理表等信息。</li>
<li>方法返回地址（Return Address）-帧数据区存储了方法返回时需要跳转到的地址。当方法执行完成（无论是正常返回还是异常终止），JVM会根据这个返回地址跳回到调用该方法的上一个栈帧</li>
<li>动态链接（Dynamic Linking）帧数据区支持动态链接机制。当方法调用其他方法或访问字段时，JVM需要解析符号引用。如果这些引用尚未解析，JVM会在运行时动态解析它们</li>
<li>异常表引用（Exception Table Reference）帧数据区还包含一个对异常表（Exception Table）的引用。异常表定义了方法中哪些字节码范围被哪些catch子句保护。当方法抛出异常时，JVM会通过异常表来确定是否能找到匹配的catch子句来处理异常</li>
<li>常量池引用（Constant Pool Reference）帧数据区包含一个对当前方法所属类的运行时常量池的引用。这个引用用于支持常量池解析，即在执行字节码指令时，JVM可以通过这个引用访问常量池中的符号引用<ul>
<li>程序计数器（Program Counter Register）</li>
</ul>
</li>
</ul>
</li>
<li>程序计数器是线程私有的，每个线程都有自己的程序计数器。线程之间的程序计数器互不干扰</li>
<li>记录当前线程所执行的字节码指令地址</li>
<li>当一个方法被调用时，程序计数器会保存方法的入口地址。当方法执行完毕后，程序计数器会恢复到调用方法时的地址，从而实现方法的返回<br>- 本地方法栈（Native Method Stack）</li>
<li>和Java虚拟机栈基本一致，本地方法栈用于支持本地方法（即非Java语言编写的代码，如C或C++代码）的执行。当Java程序通过JNI（Java Native Interface）调用本地方法时，本地方法栈会管理这些本地方法的执行状态。<br>- 执行引擎（Execution Engine）</li>
<li>负责将字节码指令解释&#x2F;编译为对应平台上的本地机器指令,执行引擎充当了将高级语言翻译为机器语言的译者。</li>
<li>解释器（Interpreter）<ul>
<li>逐条解释字节码指令，并将其转换为相应的机器指令执行。这是最基本的执行方式，简单但效率较低。</li>
</ul>
</li>
<li>即时编译器（JIT Compiler）<ul>
<li>将频繁执行的字节码编译为本地机器码，以提高执行速度。JIT编译器在运行时对热点代码进行优化编译，提升性能。</li>
</ul>
</li>
<li>垃圾回收器（GC）<ul>
<li>Java语言的核心技术特点</li>
<li>和C++相比，会自动回收不再使用的对象，释放内存资源。防止对象占用内存过多，导致内存溢出和卡顿。</li>
<li>以下是各个版本的回收器<ul>
<li>JDK8:Parallel Scavenge（新生代）+ Parallel Old（老年代）</li>
<li>JDK9到JDK21：G1（Garbage-First）</li>
<li>JDK11后增加了：ZGC（Z Garbage Collector），但不是默认开启</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>MybatisPlus</title>
    <url>/myblog/2025/11/07/%E5%90%8E%E7%AB%AF/JAVA/MybatisPlus/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><a href="https://baomidou.com/introduce/">MybatisPlus</a>一款基于 Mybatis 的增强工具,可无缝集成到任何基于 Mybatis 的项目中</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<ul>
<li>具体强大代码生成器可参考：<a href="https://baomidou.com/guide/generator.html">MyBatisPlus代码生成器</a></li>
<li>配置文件可参考：<a href="https://baomidou.com/guide/config.html">MyBatisPlus配置</a></li>
</ul>
<h1 id="快速开始SpringBoot3"><a href="#快速开始SpringBoot3" class="headerlink" title="快速开始SpringBoot3"></a>快速开始SpringBoot3</h1><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring MyBatis Plus 3.5.14 支持SpringBoot自动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置mybatis plus代码生成器 如果需要自定义代码生成器，则添加此依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加数据源<ul>
<li>MybatisPlus也支持原生Mybatis.xml相关配置</li>
</ul>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  配置spring数据源 </span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yhds_user?useUnicode=true&amp;characterEncoding=utf-8&amp;verifyServerCertificate=false&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># MyBatis Plus配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="comment"># 启动自动扫描mapperxml文件</span></span><br><span class="line">    <span class="attr">mapper-locations:</span> <span class="string">classpath*:mapperxml/*.xml</span> </span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动SpringBoot项目<ul>
<li>启动成功后，在控制台会打印如下信息：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2025-11-07T17:42:13.521+08:00  WARN 23776 --- [user-service] [           main] c.b.m.core.injector.methods.Insert       : [com.user.mapper.UserMapper.insert] Has been loaded by XML or SqlProvider or Mybatis&#x27;s Annotation, so ignoring this injection for [class com.baomidou.mybatisplus.core.injector.methods.Insert]</span><br><span class="line"> _ _   |_  _ _|_. ___ _ |    _ </span><br><span class="line">| | |\/|_)(_| | |_\  |_)||_|_\ </span><br><span class="line">     /               |         </span><br><span class="line">                        3.5.14 </span><br></pre></td></tr></table></figure></li>
<li>启动成功</li>
</ul>
</li>
</ul>
<h1 id="java代码参考"><a href="#java代码参考" class="headerlink" title="java代码参考"></a>java代码参考</h1><ul>
<li>实体类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Schema(description=&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;user_id&quot;, type = IdType.ASSIGN_UUID)</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;username&quot;)</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;密码&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;`password`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;邮件&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;email&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;手机&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;phone&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;状态&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;`status`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;update_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 部门id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;部门id&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;department_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String departmentId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所属部门（用于懒加载）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Schema(description=&quot;所属部门&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.user.entity.Department;</span><br><span class="line"><span class="keyword">import</span> com.user.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建service接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.user.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建service实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.user.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.user.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.user.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.user.util.SqlDatabaseUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后在控制层直接调用即可，mybatis plus自带了crud方法</p>
</li>
<li><p>mapper接口中定义的sql语句，可直接在mapper.xml中编写，会根据函数名对应调用sql语句</p>
</li>
</ul>
<h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><pre><code>- 延迟加载，即在调用get方法时，才会去查询数据库，而不是在初始化时查询数据库
- 配置文件参考
</code></pre>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 开启懒加载</span></span><br><span class="line">    <span class="attr">lazy-loading-enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 当设置为 true 时，懒加载的对象可能被任何懒属性全部加载，否则，每个属性都按需加载。需要和 lazyLoadingEnabled 一起使用。</span></span><br><span class="line">    <span class="attr">aggressive-lazy-loading:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Jackson序列化</title>
    <url>/myblog/2025/11/08/%E5%90%8E%E7%AB%AF/JAVA/Jackson%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a><a href="https://www.runoob.com/java/java-jackson-lib.html">Jackson</a></h1><ul>
<li><p>是一个 Java 的高性能 JSON 处理库，在SpringBoot 中，默认使用的是Jackson处理序列化</p>
</li>
<li><p>当Jackson尝试序列化未被初始化的JPA代理对象时，会触发意外懒加载的数据库查询，（Mybatis、SpringDataJPA），可能导致或N+1查询问题</p>
</li>
<li><p>具体可参考文档<a href="https://www.duoke360.com/post/42502">老郭解决文档</a></p>
</li>
<li><p>另外在SpringBoot+Mybatis中，如果使用DTO模式，那么在DTO类中，需要将JPA代理对象转为普通对象，然后再进行序列化，这样会增加额外的编码工作，但是可以完全控制输出，性能最佳</p>
<ul>
<li>而SpringBoot默认使用Jackson,使用下面得方案都无法完美解决，即完美序列化和懒加载问题。除非更改Jackson得序列化方式。</li>
<li>个人在SpringBoot2.7中正常使用Jackson是正常得。升级到SpringBoot3.4版本后遇到该问题</li>
</ul>
</li>
</ul>
<table class="table table-bordered">
<thead>
<tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr>
</thead>
<tbody>
<tr><td>DTO模式</td><td>完全控制输出，性能最佳</td><td>需要额外编码</td><td>生产环境推荐</td></tr>
<tr><td>@JsonIgnore</td><td>简单直接</td><td>无法动态控制</td><td>确定不需要的字段</td></tr>
<tr><td>HibernateModule</td><td>快速解决异常</td><td>隐藏问题本质</td><td>快速原型开发</td></tr>
<tr><td>EntityGraph</td><td>精确控制加载</td><td>需要Repository配合</td><td>需要特定关联时</td></tr>
</tbody>
</table><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Swagger</title>
    <url>/myblog/2025/11/09/%E5%90%8E%E7%AB%AF/JAVA/Swagger/</url>
    <content><![CDATA[<h1 id="swagger是一种用于描述RestFul-Api的规范，它提供了一种简单的来描述API的请求和相应参数、错误码、返回数据类型等信息，是开发者可以方便了解API使用方式。"><a href="#swagger是一种用于描述RestFul-Api的规范，它提供了一种简单的来描述API的请求和相应参数、错误码、返回数据类型等信息，是开发者可以方便了解API使用方式。" class="headerlink" title="swagger是一种用于描述RestFul Api的规范，它提供了一种简单的来描述API的请求和相应参数、错误码、返回数据类型等信息，是开发者可以方便了解API使用方式。"></a><a href="https://www.runoob.com/swagger/swagger-codegen.html">swagger</a>是一种用于描述RestFul Api的规范，它提供了一种简单的来描述API的请求和相应参数、错误码、返回数据类型等信息，是开发者可以方便了解API使用方式。</h1><ul>
<li><p>OpenAPI 始于 Swagger 规范，Swagger 规范已于 2015 年捐赠给 Linux 基金会后改名为 OpenAPI，并定义最新的规范为 OpenAPI 3.0。</p>
</li>
<li><p>Swagger是RESTful API描述规范，后更名为OpenAPI</p>
</li>
<li><p>可以根据注解和配置自动生成文档</p>
</li>
<li><p>版本问题</p>
<ul>
<li>目前主要支持SpringBoot2.x版本。</li>
<li>SpringBoot3则推荐使用Springdoc OpenAPI</li>
<li>Swagger2主要使用javax.servlet</li>
<li>Spring Boot 3.x 使用 jakarta.servlet 而不是 javax.servlet所以会出现兼容问题<ul>
<li>同时升级使用org.springdoc,内置了swagger依赖,可做到基本无缝升级。</li>
</ul>
</li>
</ul>
</li>
<li><p>以下是SpringBoot2.x版本使用swagger2案例</p>
</li>
<li><p>访问地址:</p>
<ul>
<li>低版本url：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li>
</ul>
</li>
<li><p>关于使用示例代码：</p>
<ul>
<li>依赖<ul>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- swagger ui --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在控制层可以使用元注解编辑接口相关文档信息<ul>
<li><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">&quot;Hello接口&quot;</span>,httpMethod = <span class="string">&quot;GET&quot;</span>,notes = <span class="string">&quot;这是Hello接口的详细说明。&quot;</span>)</span><br><span class="line"><span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">        <span class="meta">@ApiImplicitParam</span>(name = <span class="string">&quot;username&quot;</span>,value = <span class="string">&quot;用户名&quot;</span>,defaultValue = <span class="string">&quot;hedon&quot;</span>,paramType = <span class="string">&quot;query&quot;</span>,dataType=<span class="string">&quot;String&quot;</span>,required = <span class="literal">true</span>),</span><br><span class="line">        <span class="meta">@ApiImplicitParam</span>(name = <span class="string">&quot;password&quot;</span>,value = <span class="string">&quot;密码&quot;</span>,defaultValue = <span class="string">&quot;hedonpassword&quot;</span>,paramType = <span class="string">&quot;query&quot;</span>,dataType=<span class="string">&quot;String&quot;</span>,required = <span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">hello</span>(<span class="params"><span class="title class_">String</span> username,<span class="title class_">String</span> password</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello，your username = &quot;</span>+username +<span class="string">&quot; and your password = &quot;</span>+password;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Config编写<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 标明是配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//开启swagger功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// DocumentationType.SWAGGER_2 固定的，代表swagger2</span></span><br><span class="line">                <span class="comment">//.groupName(&quot;分布式任务系统&quot;) // 如果配置多个文档的时候，那么需要配置groupName来分组标识</span></span><br><span class="line">                .apiInfo(apiInfo()) <span class="comment">// 用于生成API信息</span></span><br><span class="line">                .select() <span class="comment">// select()函数返回一个ApiSelectorBuilder实例,用来控制接口被swagger做成文档</span></span><br><span class="line">                <span class="comment">// 扫描指定包下的接口，最为常用</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.user.controller&quot;</span>))</span><br><span class="line">                <span class="comment">//.withClassAnnotation(RestController.class) // 扫描带有指定注解的类下所有接口</span></span><br><span class="line">                <span class="comment">//.withMethodAnnotation(PostMapping.class) // 扫描带有指定注解的方法接口</span></span><br><span class="line">                <span class="comment">//.apis(RequestHandlerSelectors.any()) // 扫描所有</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 选择所有的API,如果你想只为部分API生成文档，可以配置这里</span></span><br><span class="line">                .paths(PathSelectors.any()</span><br><span class="line">                        <span class="comment">//.any() // 满足条件的路径，该断言总为true</span></span><br><span class="line">                        <span class="comment">//.none() // 不满足条件的路径，该断言总为false（可用于生成环境屏蔽 swagger）</span></span><br><span class="line">                        <span class="comment">//.ant(&quot;/user/**&quot;) // 满足字符串表达式路径</span></span><br><span class="line">                        <span class="comment">//.regex(&quot;&quot;) // 符合正则的路径</span></span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于定义API主界面的信息，比如可以声明所有的API的总标题、描述、版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(</span><br><span class="line">                <span class="string">&quot;fengyue&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://localhost:4000/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1514597997@qq.com&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;yhds学习项目API&quot;</span>) <span class="comment">//  可以用来自定义API的主标题</span></span><br><span class="line">                .description(<span class="string">&quot;yhds学习项目SwaggerAPI管理&quot;</span>) <span class="comment">// 可以用来描述整体的API</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.runoob.com/swagger/swagger-tutorial.html&quot;</span>) <span class="comment">// 用于定义服务的域名（跳转链接）</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>) <span class="comment">// 可以用来定义版本</span></span><br><span class="line">                .license(<span class="string">&quot;Swagger-的使用教程&quot;</span>)</span><br><span class="line">                .licenseUrl(<span class="string">&quot;https://www.runoob.com/swagger/swagger-tutorial.html&quot;</span>)</span><br><span class="line">                .contact(contact).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloudConfig</title>
    <url>/myblog/2025/11/09/%E5%90%8E%E7%AB%AF/JAVA/SpringCloudConfig/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://springdoc.cn/spring-cloud-config/">SpringCloudConfig</a>可以将配置信息保存在云或本地中（包括Git、SVN、本地文件系统等。它还提供了一组REST API），通过服务注册中心获取配置信息。</p>
</li>
<li><p>启动成功后会默认自动注册到Eureka中，同时会主动根据yml配置的拿去最新配置缓存。另外如果有微服务刚启动的时候，会主动去ConfigServer获取配置信息。另外每间隔段时间会主动去ConfigServer获取最新配置信息。</p>
</li>
</ul>
<h1 id="ConfigServer"><a href="#ConfigServer" class="headerlink" title="ConfigServer"></a>ConfigServer</h1><ul>
<li><p>主要去获取指定地址或资源配置后分发给ConfigClient</p>
</li>
<li><p>SpringCloudConfig服务端启动示例</p>
<ul>
<li>依赖代码参考:</li>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>启动类代码参考:</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml配置参考</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://git.com/xxx/xxx.git</span></span><br><span class="line">          <span class="comment"># 如果是私有仓库需要添加用户名和密码</span></span><br><span class="line">          <span class="attr">username:</span> <span class="number">18973960084</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">13187299283q</span></span><br><span class="line">          <span class="comment"># 搜索路径，如果有多个项目的配置文件可以用这个字段来区分</span></span><br><span class="line">          <span class="comment">#search-paths: &#x27;&#123;application&#125;&#x27;</span></span><br><span class="line">          <span class="comment"># 指定配置使用 默认分支</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># Eureka注册</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8089/eureka/</span></span><br></pre></td></tr></table></figure>

<h1 id="ConfigClient"><a href="#ConfigClient" class="headerlink" title="ConfigClient"></a>ConfigClient</h1><ul>
<li><p>主要去ConfigServer获取配置信息</p>
</li>
<li><p>Client客户端代码示例:</p>
<ul>
<li>pom.xml<ul>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud Config Client --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>bootstrap.yml<ul>
<li><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">      <span class="comment"># 配置服务地址 直接连接不用注册中心通信</span></span><br><span class="line">      <span class="comment">#uri: http://localhost:8083</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否启用注册中心服务发现去找配置服务</span></span><br><span class="line">        <span class="attr">serviceId:</span> <span class="string">config-server</span></span><br><span class="line">      <span class="comment"># profile: dev # 指定环境，默认是dev</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span> <span class="comment"># 启动时快速失败 判断服务是否可用</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Application.java 启动类参考</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li>ConfigController.java,参考获取配置信息<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getPort&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Springdoc</title>
    <url>/myblog/2025/11/09/%E5%90%8E%E7%AB%AF/JAVA/Springdoc/</url>
    <content><![CDATA[<h1 id="Springdoc详解"><a href="#Springdoc详解" class="headerlink" title="Springdoc详解"></a>Springdoc详解</h1><ul>
<li>什么是Springdoc？<ul>
<li>springdoc-openapi是一个基于OpenAPI 3规范的Java库，专门为Spring Boot项目自动生成API文档。</li>
<li>默认使用Swagger UI做完文档展示<ul>
<li>因为Swagger UI是独立的可视化工具，它只需要符合OpenAPI规范的JSON&#x2F;YAML文件就能工作。springdoc生成符合规范的OpenAPI定义，然后Swagger UI负责展示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><ul>
<li>使用Springdoc案例<ul>
<li>pom.xml依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注解使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;用户管理&quot;, description = &quot;用户相关操作API&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Operation(summary = &quot;获取用户信息&quot;, description = &quot;根据用户ID获取详细信息&quot;)</span></span><br><span class="line">    <span class="meta">@ApiResponses(&#123;</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功&quot;),</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Parameter(description = &quot;用户ID&quot;, required = true, example = &quot;123&quot;)</span> </span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置类（可选、推荐配置说明文档）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenApiConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">customOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">            .info(<span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                .title(<span class="string">&quot;用户管理系统API&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;用户管理相关接口文档&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>()</span><br><span class="line">                    .name(<span class="string">&quot;开发者&quot;</span>)</span><br><span class="line">                    .email(<span class="string">&quot;dev@example.com&quot;</span>)))</span><br><span class="line">            .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">                .description(<span class="string">&quot;更多文档&quot;</span>)</span><br><span class="line">                .url(<span class="string">&quot;https://example.com/docs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问地址<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/swagger-ui.html</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">http://localhost:8080/swagger-ui/index.html</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Eureka</title>
    <url>/myblog/2025/11/09/%E5%90%8E%E7%AB%AF/JAVA/SpringCloudEureka/</url>
    <content><![CDATA[<ul>
<li><p>SpringCloud Eureka是Netflix开发的服务发现框架，用于实现微服务架构中的服务注册与发现。Eureka包含两个组件：Eureka Server（服务注册中心）和Eureka Client（服务客户端）。</p>
</li>
<li><p>Eureka Server启动后会提供服务的注册和发现能力，微服务启动时会向Eureka Server注册自己的信息，并定期发送心跳来维持注册。Eureka Client能够从Server获取服务实例列表，实现服务的动态发现。</p>
</li>
</ul>
<h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><ul>
<li><p>作为服务注册中心，负责管理所有微服务的注册信息和服务实例状态。</p>
</li>
<li><p>SpringCloud Eureka服务端启动示例</p>
<ul>
<li><p>依赖代码参考:</p>
<ul>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>启动类代码参考:</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;EurekaApplication Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置参考</p>
<ul>
<li><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8761</span> <span class="comment"># Eureka Server默认端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 是否向Eureka注册自己</span></span><br><span class="line">        <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否从Eureka获取注册信息</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">        <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（开发环境）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka-server</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h1><ul>
<li><p>作为服务提供者或消费者，向Eureka Server注册自身信息，并从Server获取其他服务实例信息。</p>
<ul>
<li><p>Eureka Client客户端代码示例:</p>
<ul>
<li><p>pom.xml</p>
<ul>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud euraka client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>application.yml配置参考</p>
<ul>
<li><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">service-user</span> <span class="comment"># 服务名称，用于在Eureka中标识</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">        <span class="attr">service-url:</span></span><br><span class="line">            <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span> <span class="comment"># Eureka Server地址</span></span><br><span class="line">        <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment"># 注册到Eureka</span></span><br><span class="line">        <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 从Eureka获取注册表</span></span><br><span class="line">    <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 使用IP地址注册</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span> <span class="comment"># 实例ID</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloudGateway</title>
    <url>/myblog/2025/11/09/%E5%90%8E%E7%AB%AF/JAVA/SpringCloudGateway/</url>
    <content><![CDATA[<ul>
<li>SpringCloud Gateway是Spring Cloud官方推出的API网关服务，基于WebFlux和Reactor实现，提供了一种简单有效的方式来路由到API，并提供跨领域关注点，如：安全性、监控&#x2F;指标和弹性。</li>
</ul>
<h1 id="Gateway-Server"><a href="#Gateway-Server" class="headerlink" title="Gateway Server"></a>Gateway Server</h1><ul>
<li>作为API网关，负责请求路由、过滤、限流、鉴权等跨领域功能。</li>
<li>SpringCloud Gateway服务端启动示例<ul>
<li>依赖代码参考:</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动类代码参考:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml配置参考</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 开启从注册中心动态创建路由</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span>  <span class="comment"># 服务名小写</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span>  <span class="comment"># 路由ID，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span>  <span class="comment"># lb表示从注册中心获取服务，负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>  <span class="comment"># 路径匹配</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span>  <span class="comment"># 去掉前缀</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://order-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloudDoc聚合文档</title>
    <url>/myblog/2025/11/10/%E5%90%8E%E7%AB%AF/JAVA/SpringCloudDoc%E8%81%9A%E5%90%88%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><ul>
<li>在 SpringCloud 中，因为每个微服务都会使用 SpringDoc、Swagger 自动扫描自己的接口后生成对应的文档，而当多个微服务都有自己的文档后，为需统一展示，所以需要一个统一入口，这个入口就是 SwaggerUi</li>
</ul>
<h1 id="SpringDoc-说明"><a href="#SpringDoc-说明" class="headerlink" title="SpringDoc 说明"></a>SpringDoc 说明</h1><ul>
<li>在官方中可以指定只要符合 OpenApi 的规范的接口都会被 swaggerUi 展示</li>
<li>因此可以使用官方的 swaggerUi 配置即可聚合文档统一展示</li>
<li>官方针对不同模式的项目提供了不同的依赖</li>
</ul>
<table>
    <thead>
        <tr>
            <th>
                <span>依赖模块artifactId</span>
            </th>
            <th>
                <span>适用技术栈</span>
            </th>
            <th>
                <span>说明</span>
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <code>springdoc-openapi-starter-common</code>
            </td>
            <td>
                <strong>
                    <span>openapi核心库</span>
                </strong>
            </td>
            <td>
                <span>是下面各种模式的基础库、包含所有模块共享的通用功能</span>
            </td>
        </tr>
        <tr>
            <td>
                <code>springdoc-openapi-starter-webmvc-ui</code>
            </td>
            <td>
                <strong>
                    <span>Spring MVC (Tomcat)</span>
                </strong>
            </td>
            <td>
                <span>用于传统MVC基于Servlet容器的项目、提供 Swagger UI界面 和 OpenAPI 核心功能</span>
            </td>
        </tr>
        <tr>
            <td>
                <code>springdoc-openapi-starter-webflux-ui</code>
            </td>
            <td>
                <strong>
                    <span>Spring WebFlux (Netty)</span>
                </strong>
            </td>
            <td>
                <span>为基于Spring WebFlux 的应用（如Gateway）提供 Swagger UI界面 和 OpenAPI 核心功能</span>
            </td>
        </tr>
                <tr>
            <td>
                <code>springdoc-openapi-starter-webmvc-api\springdoc-openapi-starter-webflux-api</code>
            </td>
            <td>
                <strong>
                    <span>MVCApi\FluxApi</span>
                </strong>
            </td>
            <td>
                <span>分别为 MVC 和 WebFlux 应用提供 OpenAPI 核心功能，但不包含 Swagger UI 界面</span>
            </td>
        </tr>
    </tbody>
</table>


<h1 id="快速使用案例"><a href="#快速使用案例" class="headerlink" title="快速使用案例"></a>快速使用案例</h1><ul>
<li><p>模块要求</p>
<ul>
<li>使用SpringDoc自动扫描接口的微服务(若干个)</li>
<li>使用SwaggerUi的微服务(一个),负责聚合文档</li>
</ul>
</li>
<li><p>被聚合的微服务添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springdoc-openapi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加配置、默认可不配置。</p>
<ul>
<li>SpringDoc默认会自动生成并暴露OpenAPI 3规范文档，其JSON格式的默认访问路径就是 &#x2F;v3&#x2F;api-docs</li>
<li>自由当希望自定义访问路径时，可以在application.yml中添加如下配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 被聚合的微服务配置</span></span><br><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">api-docs:</span></span><br><span class="line">  <span class="comment"># 配置接口文档路径</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/v3/api-docs</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>聚合服务配置添加依赖,其中二选一</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- webMvc-api版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springdoc-openapi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- webFlux-api版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webflux-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springdoc-openapi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合服务配置添加配置(必须、否则聚合文档无法加载到对应的服务文档)</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">disabled:</span> <span class="literal">true</span>  <span class="comment"># 开发阶段建议关闭缓存，确保文档实时更新</span></span><br><span class="line">  <span class="attr">swagger-ui:</span></span><br><span class="line">    <span class="attr">urls:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">用户服务</span>  <span class="comment"># 在Swagger UI下拉列表中显示的名称</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/user-service/v3/api-docs</span>  <span class="comment"># 通过网关路由访问用户服务的API文档地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">订单服务</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/order-service/v3/api-docs</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参考成功截图<img src="../../../myblog/images/聚合文档成功案例截图.png"/></li>
</ul>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/myblog/css/markmap.css">

<script src="/myblog/js/markmap.js"></script>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
</search>
